---
title: "Genome Features as Ranges"
author: "JR"
date: "10/6/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(GenomicRanges)
library(rtracklayer)
library(tidyverse)
library(ggpubr)
library(Gviz)
source("util/_setup.R")
source("util/intersect_functions.R")
source("util/plotting_functions.R")
```

### Have you ever wanted to find overlaps between two lists of genes? Well
Iranges and GRanges are just the thing!

#### Iranges allows one to index "windows" with properties. Say you had a vector
of all genes and wanted to track start and stop. Iranges can keep the start, 
stop and width of values. So this list of ranges (start and stop) for each 
gene-length is essentially a vector or each column a gene id. With this indexing
we can now apply several attributes to these ranges. For example if an enhancer 
or other feature resided in the gene we could also track the start, stop of that
"interval". 

#### Granges is even more specially aadapted for features in a given genome. All
the start, stops for each feature is given similar to Iranges. However, we could
have a big problem since we have 23 chromosomes in the geneome! So simple start
and stop indexing isn't enough as there could be up to 23 redudant "intervals" 
that are actually unique. So we need to consider choromosome and coordinates. 
Worse we also should think about the strand. So GRanges works similar to Iranges
just having the advantage of indexing chromosome and strand to the start and stop.


#### Let's go explore the human geneome annotations from GENCODE.
We will do this by importing a GTF file of these annotaitons.
A GTF file is similar in a way to a .bed file with start stop of features
and other associated metadata that is described here:

https://uswest.ensembl.org/info/website/upload/gff.html


## Ok enough background let's start exploring the features of the human genome!
```{r}

gencode_gr <- rtracklayer::import("data/gencode.v32.annotation.gtf")

# we used rtracklayer::import to turn the annotations into start and stops (Iranges) w/ chr (Granges)

```

Now let's look at the gene_id indexable part of this GRanges
```{r}

?seqnames
  
seqnames(gencode_gr) %>% head()

# we can see that "levels" are the chromosome names and are a meta-level
```

let's get more info with table to summary using tidy verse %>%
```{R}
table(seqnames(gencode_gr)) %>% 
  summary()
# this tells us how many features there are in the genome.

table(seqnames(gencode_gr)) %>%
  head()
# This is telling us how many features are associated with each chromosome.

# Let's find out how many features the mitochondrial chr has (25th level)
table(seqnames(gencode_gr))[25] 

# Let's look in the environment at what is in @metadata that we can index into with $

```

Now let's dig in a little deeper

```{R}
table(gencode_gr@elementMetadata$gene_id) %>% 
  head()
# This tell us how many features are associated with each gene id.

# Let's see what we get with gene_name
table(gencode_gr@elementMetadata$gene_name)

# it's basically memorization of what is a gene name or gene id 

```

#TODO
Let's analyze some of the features of our genome!

```{r}

#let's organize the data frame first and put it into a data frame.

gencode_gr_length <- data.frame("gene_id" = gencode_gr@elementMetadata$gene_id,
                           "gene_name" = gencode_gr@elementMetadata$gene_name,
                           "gene_type" = gencode_gr@elementMetadata$gene_type,
                           "type" = gencode_gr@elementMetadata$type,
                           "start" = gencode_gr@ranges@start,
                           "width" = gencode_gr@ranges@width)
                           

### Ok so now we have a new data frame with the information we want from gencode_gr
## Note we see that we can index the RANGES for each gene with @ranges "level"
## in there we can get the start and width (thus infer the stop).



### Let's look at the width for mRNA genes
### We are introducing a new R base function "filter" it does as it seems.
?filter
# Notice filter is used in a few different libraries and maybe an issue if you
# use the unintended version. We want : Globally add filters to an EnsDb databas
# lets put it to use and make an mrna_df

mrna_df <- filter(gencode_gr_length, gene_type == "protein_coding", type == "gene")
hist(log10(mrna_df$width), breaks = 60)
# We filterned our gencode_gr_length variable by "gene_type" setting it to only
#"protein_coding" specified by Gencode in $gene_type (take a look at other gene types)
# We see that most of the widths are 0.5 - 1 MB large, what about lncRNA?

lncrna_df <- filter(gencode_gr_length, gene_type == "lncRNA", type == "gene")
hist(log10(lncrna_df$width), breaks = 60)
### Huh it looks like lncRNAs cover half the space of mRNAs!
### notice there are 240K and 250K lncRNA and mRNA values.
### certainly there are not that many genes in the genome. So what is happening
### these widths are associated with different properties of each gene 
### (e.g., TSS = 1 and gene body maybe 0.5 to 1 MB)
### This is why "ranges are so cool" it can have many annotations associated
### with a single gene type. 

## Now let's go find the widths associated with gene-lenght. 


### What can the metadata tell us about the human genome? Let's see
table(gencode_gr@elementMetadata$type)

## cool this tell us a lot about the genome with one line! How many genes are
## in the human genome? How many genes have non-cannonical start codons?

## Now let's go find the length of genes. Notice we pipe into a "empty data frame"
## then FILTER @elementMetadata%type to only "gene". then we ask what is the max
## width of all genes in the genome (lncRNA, mRNA etc)

genes_of_interest <- gencode_gr %>%
  as.data.frame() %>%
  filter(type == "gene",
         width == max(width))

## Here is another way to do the same thing, but we index into gencode_gr directly
## using [ ] then within these brackets we specify what we want to index:
## gencode_gr$type and set it ( == ) to "gene"
## then we use our new gencode genes that were essentially "filtered" into 
## longest_gene_index, we grab gencode_genes (our filtered list by indexing)
## pipe this to the "width function" in Iranges
?width
## the width function is piped to "which.max" base R function that finds max length
?which.max
## in the end longest_gene_index will have one value of the longest genes in genome
  
gencode_genes <- gencode_gr[gencode_gr$type == "gene"]
longest_gene_index <- gencode_genes %>%
  width() %>%
  which.max()


## Let's try some deeper indexing.
## we have gencode genes filtered to genes, take a look at this in the environment
## we still have all the metadata associated with genes. We can now use our 
## longest_gene_index to call out the one gene that is the longest
gencode_genes$gene_name[longest_gene_index]
width(gencode_genes[longest_gene_index])

## We immediately see that RBFOX1 is the longest gene in the human genome.
## How would you find the smallest gene?


# Now let's find the total amount of the genome covered by exons.
# We start by defining total_exon_length of all exons in genome.
# We use indexing to get what we want - inside gencode_gr, we want to access
# the $type index and set it to ( == ) only exons as there is more info $type
# how many other catagories are there in $type? what are they (hint:summary)
# Next we use the base Iranges "reduce" object. 
?reduce
# we see this is used by Iranges and Granges and base R. In this case we may have
# two versions of the same exon (say short and long version). We want to reduce
# this to a single exon. In this case we will merge to the longest exon. ? How
# would we reduce to the smallest exon represented?

total_exon_length <- gencode_gr[gencode_gr$type == "exon"] %>%
  GenomicRanges::reduce() %>% 
  width() %>%
  sum()

summary(total_exon_length)
# We now have the total bases covered by exons in the human genome. We also know
# the human genome is 3.9B base pairs so let's find the percentage by division:

total_exon_length/3.2e9
# Boom we can see the human genome is about 4% exons!




```



### FIND OVERLAPS: who has ever wanted to find the overlaps of their data with
### a feature of the human genome? Let's load in a chip-seq peak file and find
### the overlaps at promoter regions.

```{r}
### Let's import POLR2A Chip-seq files from k562 ENCODE project.

pol2_chip <- rtracklayer::import("data/POLR2A_consensus_peaks_filter.bed")

# We'll need to define the promoters 
gencode_promoters <- promoters(gencode_gr[gencode_gr$type == "gene"], 
                               upstream = 3e3, 
                               downstream = 3e3)
# ?promoters
# Thing to think about how does this function know which is upstream and downstream
promoter_overlaps <- findOverlaps(pol2_chip, gencode_promoters)
# Note @from @to


length(pol2_chip)
length(unique(promoter_overlaps@from))
       
percent_promoter_overlap <- length(unique(promoter_overlaps@from))/length(pol2_chip)
```

Now let's move to working with Gencode and genomic ranges on our data set!
