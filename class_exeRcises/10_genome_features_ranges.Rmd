---
title: "Genome Features as Ranges"
author: "JR"
date: "10/15/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(GenomicRanges)
library(rtracklayer)
library(tidyverse)
library(ggpubr)
library(Gviz)
source("../../../util/_setup.R")
source("../../../util/intersect_functions.R")
source("../../../util/plotting_functions.R")
```

### Have you ever wanted to find overlaps between two lists of genes? Well
Iranges and GRanges are just the thing!

#### Iranges allows one to index "windows" with properties. Say you had a vector
of all genes and wanted to track start and stop. Iranges can keep the start, 
stop and width of values. So this list of ranges (start and stop) for each 
gene-length is essentially a vector or each column a gene id. With this indexing
we can now apply several attributes to these ranges. For example if an enhancer 
or other feature resided in the gene we could also track the start, stop of that
"interval". 

#### Granges is even more specially aadapted for features in a given genome. All
the start, stops for each feature is given similar to Iranges. However, we could
have a big problem since we have 23 chromosomes in the geneome! So simple start
and stop indexing isn't enough as there could be up to 23 redudant "intervals" 
that are actually unique. So we need to consider choromosome and coordinates. 
Worse we also should think about the strand. So GRanges works similar to Iranges
just having the advantage of indexing chromosome and strand to the start and stop.


#### Let's go explore the human geneome annotations from GENCODE.
We will do this by importing a GTF file of these annotaitons.
A GTF file is similar in a way to a .bed file with start stop of features
and other associated metadata that is described here:

https://uswest.ensembl.org/info/website/upload/gff.html


## Ok enough background let's start exploring the features of the human genome!
```{r loading in GENCODE GRanges annotation file}

# we used rtracklayer::import to turn the annotations into start and stops (Iranges) w/ chr (Granges)

gencode_gr <- rtracklayer::import("/scratch/Shares/rinnclass/CLASS_2022/data/gencode.v32.annotation.gtf")

# let's take a look @metadata to see what we have in here


```

Now let's look at the gene_id indexable part of this GRanges
# seqnames
```{r seqnames}

?seqnames
  
seqnames(gencode_gr) %>% head()

# we can see that "levels" are the chromosome names and are a meta-level
```

let's get more info with table to summary using tidy verse %>%
# summary / table a GRanges object
```{R summary/table GRanges}

table(seqnames(gencode_gr)) %>% 
  summary()
# this tells us how many features there are in the genome.

table(seqnames(gencode_gr)) %>%
  head()
# This is telling us how many features are associated with each chromosome.

# Let's find out how many features the mitochondrial chr has (25th level)
table(seqnames(gencode_gr))[25] 

# we see this is the mitochondrial chromosome and has 143 elements

```


# @elementMetadata$INDEXING
```{R indexing GRanges}

# we see a lot of good infromation in @elementMetadata -- let's index it.

# let's see how many 'gene_id' values there are by indexing
table(gencode_gr@elementMetadata$gene_id) %>% 
  head()
# This tell us how many features are associated with each gene id.

# Let's see what we get with gene_name
table(gencode_gr@elementMetadata$gene_name)

# it's basically memorization of what is a gene name or gene id 

```


Let's analyze some of the features of our genome!
# Making a data frame of items in GRanges object
```{r GRanges indexing to data.frame}

#let's organize the data frame first and put it into a data frame.

gencode_gr_length <- data.frame("gene_id" = gencode_gr@elementMetadata$gene_id,
                           "gene_name" = gencode_gr@elementMetadata$gene_name,
                           "gene_type" = gencode_gr@elementMetadata$gene_type,
                           "type" = gencode_gr@elementMetadata$type,
                           "start" = gencode_gr@ranges@start,
                           "width" = gencode_gr@ranges@width)
                           
```
Ok so now we have a new data frame with the information we want from gencode_gr
Note we see that we can index the RANGES for each gene with @ranges "level"

Let's look at the width for mRNA genes
# mRNA gene width
```{R mRNA gene width}

mrna_df <- filter(gencode_gr_length, gene_type == "protein_coding", type == "gene")

# we can easily plot a histogram of mRNA gene widths.

hist(log10(mrna_df$width), breaks = 60)

# same for lncRNAs

lncrna_df <- filter(gencode_gr_length, gene_type == "lncRNA", type == "gene")

hist(log10(lncrna_df$width), breaks = 60)

# Let's see what the average gene size is. Note we can no longer use width in a DF

mean(lncrna_df$width)
mean(mrna_df$width)

# this all points to mRNAs being 2x longer than lncRNAs.
```

Now let's go find the widths associated with gene-length. 
# How many types of "gene types" are there?
```{R gene types}

table(gencode_gr@elementMetadata$type)

## cool this tell us a lot about the genome with one line!

```

let's find the longest and shortest genes in the genome!
# Finding smallest and largest gene in the genome
```{R smallest and largest genes} 

# Let's see the range of gene sizes
summary(width(gencode_gr))

# Let's turn gencode_gr into a data.frame and filter to only genes.

gencode_df <- gencode_gr %>%
  as.data.frame() %>%
  filter(type == "gene")

# Let's find the smallest genes
gencode_df %>% 
  arrange(gencode_df$width) %>%
  head()
# Same thing in more tidyverse logic (pipe the DF through code)
# Doing so we don't need to index columns with $width etc

gencode_df %>% 
  arrange(width) %>%
  head()


# Now let's find the Largest genes
gencode_df %>%
  arrange(-width) %>%
  head()


# We can also store the longest gene as an object

longest_gene <- gencode_df %>%
  filter(width == max(width))


# let's take a look at what information we have for this gene:

longest_gene

```

Now let's find the total amount of the genome covered by exons.
We start by defining total_exon_length of all exons in genome.

# we need to use reduce to collapse all the exons that overlap into the longest exon
# Exon 1.1  _____________
# Exon 1.2      _____________
# reduce    _________________
# intersect     _________


Ok let's find out what % of genome is exons!
```{R % of genome that is exons}

# first we will make an object of exons and reduce them as described above
total_exon_length <- gencode_gr[gencode_gr$type == "exon"] %>%
  GenomicRanges::reduce() %>% 
  width() %>%
  sum()

summary(total_exon_length)
# We now have the total bases covered by exons in the human genome. We also know
# the human genome is 3.9B base pairs so let's find the percentage by division:

total_exon_length/3.2e9
# Boom we can see the human genome is about 4% exons!

# We can do the same for gene bodies too

reduced_gene_bodies <- gencode_gr[gencode_gr$type == "gene"] %>%
  GenomicRanges::reduce()
hist(width(reduced_gene_bodies), breaks = 100)

```

Now let's use GRanges to find overlaps of genome features and peaks from ChIPseq.
This is probably one of the most commonly used functions in genome sciences!

First we need to import POLR2A Chip-seq files -- a simple .bed file of peaks.
# genome features overlapping chip data
```{r import Pol2 chip data}

pol2_chip <- rtracklayer::import("/scratch/Shares/rinnclass/CLASS_2022/data/POLR2A_consensus_peaks_filter.bed")

```

Now let's define the promoters using the handy promoters function in GRanges
```{R}
?promoters

# let's add 3Kb upstream and downstream from the TSS to define "promoters"
gencode_promoters <- promoters(gencode_gr[gencode_gr$type == "gene"], 
                               upstream = 3e3, 
                               downstream = 3e3)


length(gencode_promoters)
# there are ~60,000 promoters 

```

Now we have promoter ranges and peak ranges let's use findOverlaps function
```{R findoverlaps chip peaks &}

promoter_overlaps <- findOverlaps(pol2_chip, gencode_promoters)
# We get back a list of ranges of the overlaps -- kinda hard to read

# Note @from (subject) @to (query)


# sometimes it's easier to view these things in data frames
promoter_overlaps_df <- data.frame(pol2_index = promoter_overlaps@from,
                                   promoter_index = promoter_overlaps@to)

# Let's take a look at what we get
# Note that peak one overlapped 3 promoters indexed as (32,52,53)

```

How do we better conceptualize the overlaps? This get's confusing but is very simple :)
```{R}

# let's verify that peak_1 overlaps promoter 32
pol2_chip[1]
gencode_promoters[32]

# peak_1: chr1 826595-828348      * |    POLR2A_1
# promoter_32: chr1 824797-830796      - | 
# Cool we see that they overlap and promoter is on - strand.

# Let's look at another

gencode_promoters[52]

# chr1 822138-828137      + 
# We see there is another promoter close by on the other strand and overlaps = cool.

```

It's strange that so many promoters are overlapped by 1 peak
Let's see if this was a big peak?
```{R}

width(pol2_chip[1])

# Ok it's kinda big, but this may mean all the promoters are close by.
```

Now let's get into the logic of overlaps in small steps as it can get confusing.

```{R}

# reminder @from is peak file and @to is the promoter annotations
table(promoter_overlaps@from)[1:3]

# This tells us that peak 1 had 3 overlaps, peak 2 had 2 and 3 had 2 overlaps with promoters.

```


Let's dig into what information results from findOverlaps
```{R}

# Total number of peaks (we can also see this in pol2_chip GRanges)
length(pol2_chip)
# 10,255

# Let's see a larger overlap index
table(promoter_overlaps@from)

# let's make a data-frame and get acquainted 
at_from_table <- table(promoter_overlaps@from) %>% as.data.frame()
at_to_table <- table(promoter_overlaps@to) %>% as.data.frame()

# Number of peaks that overlap promoters
length(table(promoter_overlaps@from))
length(unique(promoter_overlaps@from))
# 10,255 peaks, have 7,738 overlaps in @to (promoters)

# Now let's see the total number of events that occurred (sum of all #'s in table)
length(promoter_overlaps@from)
# 13,771 -- how is this possible?? There are only 10,000 peaks ??
# Let's look in table
table(table(promoter_overlaps@to))

# Thus, 13,771 = 12,831 + 464 + 464 + 4 + 4 + 4

# Let's see the same from the promoter perspective
length(table(promoter_overlaps@to))
# 13,299 promoters were overlapped in total (note indexing by promoter #)

```

See this is a bit confusing, we have:

10,255 peaks
7,738 peaks overlapped in @to
13,771 promoters overlaps @from
13,299 promoter overlaps @to

So we have 472 promoters that had more than one overlap (464 + 8) !!

# How do we make sense of this

So 7,738 overlapping peaks resulted in 13,771 overlaps with promoters.
This is because some peaks overlapped more than one promoter. And a total
of 13,299 promoters were overlapped.


Let's make some data frames to better understand what is happening
```{R}

# Let's look at all the peak overlaps (13,771) in two different data frames:
# Data frame from peak perspective (@from)
overlapping_pol2 <- pol2_chip[promoter_overlaps_df$pol2_index] %>% 
  as.data.frame()

# Data frame from promoter perspective (@to)
overlapping_promoters <- gencode_promoters[promoter_overlaps_df$promoter_index] %>% as.data.frame()

# >> Note both are 13,771 long

# Now let's merge these two data frames (they both have the same gene_id)
# We are using the promoter_overlaps_df we made above as it's the same as
# overlapping_pol2

promoter_overlaps_df$promoter_gene_id <- overlapping_promoters$gene_id

# adding more data to the same data frame (gene_name & peak_name)
promoter_overlaps_df$promoter_gene_name <- overlapping_promoters$gene_name
promoter_overlaps_df$peak_name <- overlapping_pol2$name

# Basically we can see 7,738 peaks overlapped 13,299 promoters.
length(unique(promoter_overlaps_df$peak_name))
length(unique(promoter_overlaps_df$promoter_gene_id))



```


*********************
EXCERCISE
*********************


What happens if we shrink the promoter windows? Some standards are 2Kb upstream 1kb down stream. 
Some could be as small as 1Kb upstream 500Kb downstream. Try two different promter window sizes and record
@from and @to values as well as unique peaks. 

