---
title: "R-eading_installing_files_for_R"
author: "JR"
date: "9/27/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(GenomicRanges)
library(rtracklayer)
library(tidyverse)
library(ggpubr)
library(Gviz)
source("util/_setup.R")
source("util/intersect_functions.R")
source("util/plotting_functions.R")
```

# Welcome to RStudio-viz! Let's take a little tour.

First we need to learn how to install packages. Let's find out what version of R we are using.

Simply type version in the console.

Now we will use Install.packages() for most packages. This will install any packages in CRAN repository. Let's try one.

```{R install packages}

?install.packages
install.packages("tidyverse")

```

Cool we have our first package installed.

However sometimes we ned to install from Bioconductor and need to use BiocManager::install function

```{R install BiocManager}

if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager", version = '3.10')
BiocManager::install("GenomicRanges")

```

# Now try installing the packages listed above. 

Some packages like GenomicRanges are from Bioconductor and those will
need to be installed with the BiocManager::install function.

# ------------------------- R basic data analysis  -------------------------
# All the files needed for this exeRcise can be downloaded here

```{BASH DOWNLOAD DATA NEEDED FOR LESSON IF NOT IN CLASS}

#  https://www.dropbox.com/sh/76etjxl10v2hcuc/AAAIk9a6aMhw8CvUtKlFnMn6a?dl=0

wget (url_above) # check your directory.

```


Now let's use an example data file we will produce and how we can use R to do
some quick analyses.

We will addres the following two questions as an example:
# How many peaks does each DBP have? 
# How much of the genome do they cover?

```{r read in peaks per DBP}

# read in csv file that has number of peaks and genome coverage
peaks_per_dbp <- read_csv("../data/number_of_peaks_per_dbp.csv")

# Now we have an object in the environment that is called 'peaks_per_dbp'
head(peaks_per_dbp)

# This is a tibble or data frame object you can think of like excel sheet for now
# More on Tibble here:
# https://tibble.tidyverse.org/
```

# Using 'table' & 'summary to get information from files
```{R table and summary}

# Let's get more infomration about these peaks with table

table(peaks_per_dbp$dbp)

# Not very useful in this case because there is only one entry for each DBP

summary(peaks_per_dbp$num_peaks)
# Ok this is super helpful - we see the quartiles for each of the categories

```


# Which DBP has the most or least peaks?

```{r DBP max min peaks}

# We can take a shortcut using 'summary' to find out the smallest and largest
summary(peaks_per_dbp$num_peaks)

# Now we will use filter which will allow us to do much more.
peaks_per_dbp$num_peaks > 40000

```

We see this produces the T and F for each DBP and we can see 2 DBPs (but we don't know the name :(

```{R filter}

#To solve this we can use filter and set a variable using <-
max_peaks <- dplyr::filter(peaks_per_dbp, num_peaks > 40000)


# Let's see what else we can do with filter

?filter
#Let's filter on a couple of factors
max_peaks <- dplyr::filter(peaks_per_dbp, num_peaks > 30000, total_peak_length == 133310967)

```


# Let's find the DBP(s) with the fewest peaks (we saw in summary it was 263)
```{r}
min_peaks <- filter(peaks_per_dbp, num_peaks < 264)
```

# Let's find the number of peaks for a specific gene say POLR2A
```{r}
gene_pol2 <- filter(peaks_per_dbp, dbp == "POLR2A")
```


# Now let's make a new column in the file table
```{r}
peaks_per_dbp$newcol <- "What?"
```

# Now let's assign a number to each DBP in another new column
```{R}
peaks_per_dbp$id <- 1:nrow(peaks_per_dbp)
```

# Now let's [INDEX] data to the console using []
# Basic indexing syntax
# More on R indexing https://stats.idre.ucla.edu/r/modules/subsetting-data/
```{r}
peaks_per_dbp[1:5, 1]
```

# Let's remove a column using indexing
```{R}
peaks_per_dbp <- peaks_per_dbp[,-4]
```


# Now let's make a plot of the data. First a histogram of number of peaks for each DBP
```{r}
?hist
hist(peaks_per_dbp$num_peaks, breaks = 40)
```

# Now let's plot the number of peaks versus peak width.
```{r}
plot(x = peaks_per_dbp$num_peaks, y = peaks_per_dbp$total_peak_length)
```

# Now let's dig into the data file to subset it into the genes we are interested in.
```{r}
# First let's make a list of genes we want. To make a vector of characters we use the c() function
genes <- c("POLR2A","POLR2B", "SUPT5H")
# Now lets make it a searchable index with paste0 (?paste0)
pattern_to_search <- paste0(genes, collapse = "|")
```

# It's worth noting that things can be accomplished in many different ways in R.
# Here we'll get to the same subset of row entries two different ways. 
```{r}
#first let's use grepl
?grepl
grepl(pattern_to_search, peaks_per_dbp$dbp)

# Let's get some information more succinctly with table added to the command
table(grepl(pattern_to_search, peaks_per_dbp$dbp))

# Now let's get all the information for these genes by indexing peaks_per_dbp
# Note that grepl is searching in the column indexed ($dbp) and then takes all rows and columns
# R syntax is rows,columns. So df[,] = all rows/cols, df[1,] = first row all columns etc.
ppdbp_subset <- peaks_per_dbp[grepl(pattern_to_search, peaks_per_dbp$dbp),]
```

# Now let's do the same thing with filter in tidyverse syntax ' %in% ' (best to use when possible)
```{R}
#Let's play with tidyverse using %in%
peaks_per_dbp$dbp %in% genes
# This is identical output to grepl(pattern_to_search, peaks_per_dbp$dbp) used above
```

# Now we will set a variable as the output using filter and then the code we just ran
```{r}
ppdbp_subset <- dplyr::filter(peaks_per_dbp, dbp %in% genes)
```

# Here is a little more tidyverse in action using the pipe %>% and start fresh with a new peaks_per_dbp

```{r}
#TODO debug why error col to rownames?
peaks_per_dbp <- read_csv("../data/number_of_peaks_per_dbp.csv") %>%
peaks_per_dbp <- peaks_per_dbp %>%
  rownames_to_column(var = "dbp")
ppdbp_subset <- peaks_per_dbp[genes,]
```


# Now let's run functions on the data in a given column with MUTATE (my favorite function)
# head(peaks_per_dbp) -- we can see that the total length is quite long, let's make it in Millions
```{r}
peaks_per_dbp <- peaks_per_dbp %>%
  dplyr::mutate(tpl_m = total_peak_length / 1000000)
```

# instead of removing it we can just set the new col to the old col name

```{r}
peaks_per_dbp <- peaks_per_dbp %>% 
  mutate(total_peak_length = total_peak_length / 1000000) 

# Now let's plot it
hist(peaks_per_dbp$total_peak_length)
```

# Now let's explore the power of mutate syntax with a function.
# Technically, what we just did was a function (division is a function :)
# We will try it with a more complex function using ifelse logic

```{r}

peaks_per_dbp <- peaks_per_dbp %>% 
  mutate(peak_genome_coverage = ifelse(total_peak_length < 1, "small",
                          ifelse(total_peak_length < 30, "medium", "large")))
```



*********************
EXCERCISE
*********************

Use what we learned above to plot a historgram of all the proteins that are in the medium sized category for total genome coverage.

Make a table with just the medium coverage DBPs
