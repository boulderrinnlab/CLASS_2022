---
title: "19_Rnaseq_diff_expression"
author: "JR"
date: "10/11/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(tidyverse)
library(tximport)
library(DESeq2)
library(ggrepel)

source("../../../util/plotting_functions.R")
source("../../../util/_setup.R")
```

Today we will performing differential expression on HEPG2 RNAseq data. We will focus on comparing nuclear versus cytoplasmic RNAs.

First let's read in teh sample sheet in our data folder

```{r import sample sheet}
samplesheet <- read_csv("../../../data/samplesheet.csv")

# For now we are just comparing nuclear versus cytoplasmic so let's filter:

samplesheet_filtered <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))
```

Now let's read in the genome features also in our data folder

```{r import genome features}

# Importing genome annotations
gencode_gtf <- rtracklayer::import("../../../data/gencode.v32.annotation.gtf")

# Let's reduce this big GRanges list to just genes
genes <- gencode_gtf[gencode_gtf$type == "gene"]

# in 'list info' we can see gene_id and gene_name (note copy link in R Studio !!)
genes@elementMetadata@listData[["gene_id"]]
genes@elementMetadata@listData[["gene_name"]]

# Cool so we know where are gene names and ids are.

```

Ok, next step is to read in GENE COUNTS (not TPM) This was exported from the NF_CORE RNAseq pipeline in the salmon folder. We want "salmon_merged_gene_counts.csv
```{r reading in salmon counts convert to matrix}

# DEseq requires a matrix of raw counts
counts <- read_csv("/Shares/rinn_class/data/CLASS_2022/data/rnaseq/results/salmon/salmon_merged_gene_counts.csv") %>%
  # this will remove the gene_id column and use it as 'meta' data in matrix
  column_to_rownames("gene_id") %>%
  as.matrix()

# Nice now we have a matrix we need to import to DeSeq
# But first we still have some more file cleaning up to do
```


Cleaning up samples sheet to just nuclear and cytoplasmic
with more accessible names that the ENCODE accession number.
```{R}

# First let's put the counts columns in the same order as the samplesheet
counts <- counts[,samplesheet$sample_id]

# This is a handy check point to make sure the labels in 
# sample sheet and counts are similar
all(colnames(counts) == samplesheet$sample_id)

# Now we know they're in the same order, and we can change the names
colnames(counts) <- samplesheet$sample_name


# Now we will filter the sample sheet to just nuclear and cytoplasmic
# **** for class exercise you may want to run the lines below that round 
# numbers and get everything ready for DeSeq2. Then filter later.*****

samplesheet_filtered <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))

```

We are almost ready, just a few more things to double check
For example, that the sample sheet and the counts are in right order.
Moreover, DeSeq2 requires integers and that condition is a factor.
```{r}

# make sure the count columns and the sample rows are in the same order
# we're using a subset, so this will also filter to just the cols that we want.
dim(counts)

samplesheet_filtered$sample_name %in% colnames(counts)
# Cool, the 4 samples in filtered are same as counts

# now we will reduce the counts matrix to just these 4 samples.
counts_nuc_cyto <- counts[, samplesheet_filtered$sample_name]


rownames(samplesheet_filtered) <- samplesheet_filtered$sample_name
stopifnot(all(rownames(samplesheet_filtered) == colnames(counts)))

# The first factor level is the "control" and all the other levels
# will be compared back to it.
samplesheet_filtered$condition <- factor(samplesheet_filtered$condition, 
                                         levels = c("nuclear_fraction", "cytosolic_fraction"))


# DESeq2 needs an integer count matrix.
# featureCounts will provide integer counts
# but because salmon is fancy and uses the 
# transcript level counts to summarize to gene level
# the count data is continous. We need to round it to 
# the nearest integer
counts <- round(counts)
mode(counts) <- "integer"

# One other thing that can be done is to filter out the
# genes with low counts across the dataset.
# This will subtly change the results.. but I believe it is subtle
counts_filtered <- counts[rowSums(counts) > 1,]


dds <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = samplesheet_filtered,
                              design = ~ condition)

dds <- DESeq(dds)
###
rlog_counts <- rlog(dds, blind = TRUE)
rlog_counts_matrix <- assay(rlog_counts)


hist(rowVars(rlog_counts_matrix))

rlog_var_genes <- rlog_counts_matrix[rowVars(rlog_counts_matrix) > 3,]

# Let's take the top variable genes
# matrix of log normalized counts
# for all samples 
# cols: f1_1, f1_2, f2_1,..
# rows: genes
# you could cluster this, but largely it would dominated by abundance
# so you want to zscale the rows
scaled_counts <- t(scale(t(rlog_var_genes)))
# this is what you'd want to cluster
pheatmap::pheatmap(scaled_counts, show_rownames = FALSE)
# Other functions which give normalized counts from deseq: vst, rlog
```

```{r}
# We now have the object set up to 
# run the differential expression analysis
# and it's a very simple command to do so. 
# Even though it's doing a lot of complicated statistics!
# dds <- DESeq(dds)
```

```{r}
# The first thing that we'll want to do is make a PCA plot.
# rlog_counts <- rlog(dds)

rld_pca <- prcomp(t(assay(rlog_counts)))
rld_prcomps <- rld_pca$x %>% as.data.frame() %>%
  rownames_to_column("sample_name") %>%
  select(sample_name, PC1, PC2)
rld_prcomps <- merge(samplesheet, rld_prcomps)
# install.packages("ggrepel")


g <- ggplot(rld_prcomps, aes(x = PC1, y = PC2, color = condition, label = replicate))
g + geom_point() +
  geom_text_repel()
```

```{r}
# Now we can check out the results from this analysis.
resultsNames(dds)
res <- results(dds, name = "condition_cytosolic_fraction_vs_nuclear_fraction")

# It's easier to view it as a data.frame so we'll convert it.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s)
```

```{r}
# We can now make some standard plots to check out these results

# Volcano plot
ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point()

# MA plot
ggplot(res_df, aes(x = log10(baseMean), y = log2FoldChange)) + 
  geom_point()

# P-value histogram
hist(res_df$padj)
```

```{r}
# Now on your own, find the top 10 genes that are nuclear vs. cytoplasmic.
# There's lots more to explore with this type of data and these results
# and we're opening to exploring more if you guys would like!
# This is just the very basics.
```

# DESeq with all subcellular fractions

```{r}
samplesheet <- read_csv("rnaseq/samplesheet.csv")

# We of course need to swap the labels for total and insoluble cytoplasmic
# From looking in the browser at genes that should be nuclear: NEAT1 for ex.
# We have concluded that 
# hepg2_R2 -- is whole cell / total
# hepg2_insoluble_cytoplasmic_fraction_R2 -- is whole cell / total
# hepg2_R1 -- is insoluble_cytoplasmic
# hepg2_insoluble_cytoplasmic_fraction_R1 -- is insoluble_cytoplasmic

# The cleanest thing to do would be to fix it on the design file and re-run the nf-core pipeline,
# but for now we can swap it here.
samplesheet[which(samplesheet$sample_name == "hepg2_R1"), "condition"] <- "insoluble_cytoplasmic_fraction"
samplesheet[which(samplesheet$sample_name == "hepg2_insoluble_cytoplasmic_fraction_R2"), "condition"] <- "total"
```

```{r}
# We now won't filter the sample sheet and we'll read in all the data
files <- file.path("rnaseq/results/star_salmon",
                   samplesheet$sample_name, 
                   "quant.sf")
names(files) <- samplesheet$sample_name

txi <- tximport(files, type = c("salmon"), tx2gene = tx2gene)
```

```{r}
# We'll do the same housekeeping as before to make sure the genes and the samples are in the same order as
# the count data.
names(genes) <- genes$gene_id
genes <- genes[rownames(txi$counts)]
stopifnot(all(genes$gene_id == rownames(txi$counts)))

# Create rownames for the sample sheet and then use that to re-order
samplesheet <- samplesheet %>%
  mutate(row_names = sample_name) %>%
  column_to_rownames("row_names")
samplesheet <- samplesheet[colnames(txi$counts),]
stopifnot(all(rownames(samplesheet) == colnames(txi$counts)))
```

```{r}
# In order to make the total (whole cell) condition be the one that everything is compared back to
# we will want to set the factor levels with "total" first
samplesheet$condition <- factor(samplesheet$condition, levels = c("total", "membrane_fraction", 
                                                                  "insoluble_cytoplasmic_fraction", 
                                                                  "cytosolic_fraction", "nuclear_fraction"))

dds <- DESeqDataSetFromTximport(txi,
                                design = ~ condition,
                                colData = samplesheet,
                                rowData = genes)

# Run the DESeq stats
dds <- DESeq(dds)
```

```{r}
# We now have a bunch more results
resultsNames(dds)

# Let's just look at one of the results


res <- results(dds, name = "condition_membrane_fraction_vs_total")

res_shrunken <- lfcShrink(dds, coef = "condition_membrane_fraction_vs_total",  res = res)


# Let's quickly compare the unshrunken vs shrunken fold changes.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

# Set the x-axes the same.
summary(res_df$log2FoldChange)

ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)


res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

ggplot(res_shrunken_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)
```

```{r}
# Okay, now that we have results for each comparison back to total,
# we can combine the fold changes into a matrix and make a heatmap / cluster the genes
# By which cellular fraction they are enriched in.
# A good starting point would be to use a for loop to make a data.frame with all the results
# and then you can make that into a matrix with pivot_wider.
results_names <- resultsNames(dds)
# We don't care about the intercept, so we can leave that out
results_names <- results_names[-1]

res_df <- data.frame("gene_id" = character(), 
                     "baseMean" = numeric(), 
                     "log2FoldChange" = numeric(), 
                     "lfcSE" = numeric(),
                     "stat" = numeric(),
                     "pvalue" = numeric(),
                     "padj" = numeric(),
                     "gene_name" = character(),
                     "result_name" = character())

res_shrunken_df <- data.frame("gene_id" = character(), 
                              "baseMean" = numeric(), 
                              "log2FoldChange" = numeric(), 
                              "lfcSE" = numeric(),
                              "stat" = numeric(),
                              "pvalue" = numeric(),
                              "padj" = numeric(),
                              "gene_name" = character(),
                              "result_name" = character())


for(i in 1:length(results_names)) {
  results_name <- results_names[i]
  res <- results(dds, name = results_name)
  res_shrunken <- lfcShrink(dds, coef = results_name,  res = res)
  
  tmp_res_df <- res %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  
  tmp_res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  # Append to full data.frame
  res_df <- bind_rows(res_df, tmp_res_df)
  res_shrunken_df <- bind_rows(res_shrunken_df, tmp_res_shrunken_df)
}

# Let's move forward with the shrunken log fold-changes
# First let's label the genes as being significant in any condition or not.
res_shrunken_df <- res_shrunken_df %>%
  group_by(gene_id) %>%
  mutate(sig = ifelse(any(padj < 0.05), "sig", "ns"))

# Let's clean up the column names a little bit
res_shrunken_df <- res_shrunken_df %>%
  mutate(subcellular_fraction = gsub("condition_|_fraction_vs_total", "", result_name))

sig_res_shrunked_df <- res_shrunken_df %>%
  filter(sig == "sig")

lfc_matrix <- sig_res_shrunked_df %>% 
  dplyr::select(gene_id, log2FoldChange, subcellular_fraction) %>% 
  pivot_wider(names_from = "subcellular_fraction", values_from = "log2FoldChange") %>%
  column_to_rownames("gene_id") %>%
  as.matrix()

pheatmap::pheatmap(lfc_matrix, show_rownames = FALSE, breaks = seq(-3, 3, length.out = 100))
```
