---
title: "19_Rnaseq_diff_expression"
author: "JR"
date: "10/11/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(tidyverse)
library(tximport)
library(DESeq2)
library(ggrepel)
library(pheatmap)

source("../../../util/plotting_functions.R")
source("../../../util/_setup.R")
```

Today we will performing differential expression on HEPG2 RNAseq data. We will focus on comparing nuclear versus cytoplasmic RNAs. We can use this data to find genes that are nuclear or cytoplasmic enriched. We can use this data to determine if the high-binding promoters are biased for nuclear or cytoplasmic RNAs. Meaning the number of binding events indicates if the RNA product is sent to the cytoplasm (typically) or the nucleus. We can also use this data to determine if lncRNAs or mRNAs have similar or different nuclear/cytoplasmic localizations.



First let's read in teh sample sheet in our data folder
```{r import sample sheet}
samplesheet <- read_csv("/scratch/Shares/rinnclass/CLASS_2022/data/samplesheet.csv")

# For now we are just comparing nuclear versus cytoplasmic so let's filter:

samplesheet_filtered <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))
```

Now let's read in the genome features also in our data folder
While we are at it, let's also print these out to make this go quicker in the future.
```{r import genome features}

# Importing genome annotations
gencode_gtf <- rtracklayer::import("/scratch/Shares/rinnclass/CLASS_2022/data/gencode.v32.annotation.gtf")
# that took awhile let's make genome annotation files that can be quickly read in the future


# Let's reduce this big GRanges list to just genes
genes <- gencode_gtf[gencode_gtf$type == "gene"]


# let's make an object of gene_id and names
# we just saw above we can get both gene_id and name from 'genes'
# We can convert to DF for readability.

g2s <- genes %>% as.data.frame() %>%
  dplyr::select(gene_id, gene_name)

write.csv(g2s, "g2s.csv")

# Nice now we have a handy conversion table of gene_id & gene_name
```

Ok, next step is to read in GENE COUNTS (not TPM) This was exported from the NF_CORE RNAseq pipeline in the salmon folder. We want "salmon_merged_gene_counts.csv
```{r reading in salmon counts convert to matrix}

# DEseq requires a matrix of raw counts
counts <- read_csv("/scratch/Shares/rinnclass/CLASS_2022/data/rnaseq/results/salmon/salmon_merged_gene_counts.csv") %>%
  # this will remove the gene_id column and use it as 'meta' data in matrix
  column_to_rownames("gene_id") %>%
  as.matrix()

# Nice now we have a matrix we need to import to DeSeq
# However it has all the samples so we need to orgnize a bit.
```

Making an rlog counts matrix for all samples -- can read in to start in future
```{R making counts table and normalized Rlog counts}

# First let's put the counts columns in the same order as the samplesheet
# If they are not then we would essentially be randomizing our data later!!

counts <- counts[,samplesheet$sample_id]

# This is a handy check point to make sure the labels in 
# sample sheet and counts are similar

all(colnames(counts) == samplesheet$sample_id)

# Now we know they're in the same order, and we can change the names

colnames(counts) <- samplesheet$sample_name

# Deseq wants round numbers so we are going to round them here:

counts <- round(counts)

# now we want to get rid of all genes with 0 across all samples.

counts_filtered <- counts[rowSums(counts) > 1,]


# Next we want to normalize these counts 
# mostly to account for low abundance and noisey genes
# We need to do this in four steps:

# (1) first run DESeq2 by creating a dds object.

dds <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = samplesheet,
                              design = ~ condition)

# (2) run DESeq2 on dds object

dds <- DESeq(dds)

# (3) arrive at rlog normalized counts table!
# bild = T means it will normalize with out the "design ~ condition"
# seems redundant but these are the steps :)

rlog_counts <- rlog(dds, blind = TRUE)

# (4) now we retrieve the values using assay (an accessor function into rlog_counts)

rlog_counts_matrix <- assay(rlog_counts)

# Let's round the numbers now for better storage of this data

rlog_counts_matrix <- round(rlog_counts_matrix)


# Now we can write this out and START from here in the future.

write_rds(rlog_counts_matrix, "rlog_count_matrices/rlog_counts_all_rounded.rds")

# reading back in to be sure we can start here in the future.
rlog_counts_matrix <- read_rds("rlog_count_matrices/rlog_counts_all_rounded.rds")
```


Now let's make a sample sheet we can use to compare nuc/cyto samples.
```{R nuclear and cytoplasmic samplesheet}
# Now we will filter the sample sheet to just nuclear and cytoplasmic

samplesheet_filtered <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))

# Nice now we have a reduced sample sheet that is well organized.

# Next, let's triple check that the reduced sample sheet and counts
# have the same sample names.

samplesheet_filtered$sample_name %in% colnames(counts)

# Cool, the 4 samples in filtered are same as counts
# Now let's look at samplesheet_filtered.
# Not the rownames are numbers -- this is 'meta' information we need.
# So let's make the rownames the names of the samples.

rownames(samplesheet_filtered) <- samplesheet_filtered$sample_name
# Now if we look at this object we see rownames as sample_name - nice.

# let's write out this samplesheet for future use

write.csv(samplesheet_filtered, "sample_sheets/samplesheet_filtered.csv")

# writing into be sure we are comfortable using this in the future.

samplesheet_filtered <- read.csv("sample_sheets/samplesheet_filtered.csv")

```


.
```{r nuc/cyto  counts}





# now we will reduce the counts matrix to just these 4 samples.
counts_nuc_cyto <- counts[, samplesheet_filtered$sample_name]

# This is a good way to triple check everything is in order.

stopifnot(all(rownames(samplesheet_filtered) == colnames(counts_nuc_cyto)))
# Great this evaluated to true and thus moved on -- we would get an error message otherwise.

```

We are almost ready, last things to check:

DeSeq2 requires integer data and that condition is a factor. We will make
sure these data files are in the right data format (good example of data types in R!)

Most importantly we need to add a 'meta' factor for DeSeq to know which order the samples
were analyzed -- this is critical !! Log fold change doesn't mean much with out knowing the order.
```{R}

# NOTE: DeSeq wants the control as a factor (fct), currently (chr)
# The first factor level is the "control" and all the other levels
# will be compared back to it.

# Let's make the condition a factor:

samplesheet_filtered$condition <- factor(samplesheet_filtered$condition, 
                                         levels = c("nuclear_fraction", "cytosolic_fraction"))

# now we see condition became a factor!
# So now a log fold change of < 1 = cytosolic, and greater than 1 = nuclear.
# This is subtle but important.

# Ok now we need to turn the counts into integer data (int)

counts <- round(counts_nuc_cyto)
# This will round the counts, but still need to change to integer

mode(counts_nuc_cyto) <- "integer"
# We just coerced the data to integer and can now see that in env (int).

# Ok, one final step filtering some of the gene counts out.
# Let's fileter to genes that have at least one count across cols.
nuc_cyto_counts_filtered <- counts[rowSums(counts) > 1,]

```


Ok we are now ready for 'DeSeq land' we will be calling several
functions from DeSeq. We need to know a few things that DeSeq requires.
We will explore these now.
```{R}

# we dirst set up a dds (Distributed Data-structures in R)
# we have created a count matrix and thus will use 'DESeqDataSetFromMatrix'
# the params for this are:
# 'countData' (the counts matrix)
# 'coldData' where to get column data for which samples are which 
# design is the analysis model and we are using condition column in sample sheet.


dds <- DESeqDataSetFromMatrix(countData = nuc_cyto_counts_filtered,
                              colData = samplesheet_filtered,
                              design = ~ condition)

# after creating the dds we run the DESeq function on this dds.
# NOW WE RUN DESEQ !!

dds <- DESeq(dds)

# Now let's get the rlog normalized nuc/cyto counts like we did above
# running rlog normalization on dds (that is only nuc and cyto now)
# CAREFUL of what is in your dds when running this part :)

rlog_counts_nuc_cyto <- rlog(dds, blind = TRUE)

# exctracting count matrix with assay()

rlog_counts_matrix_nuc_cyto <- assay(rlog_counts)

# This is another handy matrix to load in so let's write it out

write_rds(rlog_counts_matrix_nuc_cyto, "rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

# reading in so comfortable starting here with nuc/cyto

rlog_counts_matrix_nuc_cyto <- read_rds("rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

# Nice now we can just start here in the futre.
```

# START POINT
All the work we have done above can be skipped by 
reading in the following files.

```{r START POINT}

# All normalized counts 
rlog_counts_matrix <- read_rds("rlog_count_matrices/rlog_counts_all_rounded.rds")

# Nuc and cyto normalized counts
read_rds("rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

samplesheet <- read_csv("/scratch/Shares/rinnclass/CLASS_2022/data/samplesheet.csv")



```








Now let's cluster the data and make a heatmap of differntially expressed genes in nuc/cyto.
Fist we need the right type of normalized quantificaiton across samples that DESeq provided
```{R}

# Deseq porvided us with a really useful normalized quantification in RNAseq.
# to retrieve this we use the DESeq function 'rlog'

rlog_counts <- rlog(dds, blind = TRUE)
# we see this is a DESeq object - let's transform into a matrix for clustering.

rlog_counts_matrix <- assay(rlog_counts)
# let's take a look at the distribution of 'variability' across samples.
# we use rowVars from the rlog_counts_matrix.

hist(rowVars(rlog_counts_matrix))

# Based on this we see that most of the data is 0 or not differential across samples.
# somewhere around 2 the distribution changes so let's filter there:

rlog_var_genes <- rlog_counts_matrix[rowVars(rlog_counts_matrix) > 2,]
# cool we have the top 1,000 ish genes that are variable between nuc/cyto.

# Now we need to "row center" the values across samples. This simply means:
# we take the mean of the row and divide it by each value. Tells where up and down.

# r can only scale in columns so we are going to transmute the matrix (counts as cols)
# then flip the matrix right back

scaled_counts <- t(scale(t(rlog_var_genes)))

# Nice and for all this hard work, how about a heatmap:

pheatmap(scaled_counts, show_rownames = FALSE)
# Awesome that looks just as it should let's save it!

pdf("figures/nuc_cyto_var_genes_heatmap.pdf")
pheatmap(scaled_counts, show_rownames = FALSE)
dev.off()

```


The clustering of the most variable genes show a clear separation of nuc and cyto samples.
But now let's see how similar and different the samples and replicates are with all values.
To do this we will use Principle Component Analysis (PCA)
```{r}
# The first thing that we'll want to do is make a PCA plot.
# we will use another base R function called 'assay()'
# This will summarize the matrix values of each sample
# 'prcomp()' is the principle component analysis function.

?prcomp
?assay

rld_pca <- prcomp(t(assay(rlog_counts)))
rld_prcomps <- rld_pca$x %>% as.data.frame() %>%
  # note that x is in rld_pca as the PCA values
  rownames_to_column("sample_name") %>%
  select(sample_name, PC1, PC2)
rld_prcomps <- merge(samplesheet, rld_prcomps)
# install.packages("ggrepel")


ggplot(rld_prcomps, aes(x = PC1, y = PC2, color = condition, label = replicate))
geom_point() +
geom_text_repel()

```

Now let's look deeper into the results held in dds object
```{r}

# let's check out dds
resultsNames(dds)

# not very interesting because it's an DESeq object.
# 'results' is a DESeq function that can extract results.
# ?results

res <- results(dds, name = "condition_cytosolic_fraction_vs_nuclear_fraction")

# It's easier to view it as a data.frame so we'll convert it.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s)

# Nice now we have a DF with a lot of good info for each gene.
```

Let's make some standard RNAseq or gene-expression plots:
```{r}

# First let's take a look at res_df
# What is the most nuclear RNA? Most cytoplasmic? Does that make sense?

# Now we can look at the data with some standard QC plots:

#TODO add color (color by noncoding or not?)
# Volcano plot
ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = -log10(padj > 90))) + 
  geom_point()


# MA plot (this make a take a min)
ggplot(res_df, aes(x = log10(baseMean), y = log2FoldChange)) + 
  geom_point()

# This is a good QC plot and shows the pvalues are not biased to low "base-mean" levels

# let's see the range of pvalues:
hist(res_df$padj)

# how many genes above 0.05 padj?

num_sig <- res_df$padj < 0.05
summary(num_sig)

# We see about 14,268 genes are differentiall expressed.
```


Let's now save res_df as a data.frame!

```{r}

# write.csv2 didn't work for some reason??

# Let's save this dataframe !!

write.table(res_df, "results/nuc_cyto_diff_expression_res_df.csv")



test <- read.table("results/nuc_cyto_diff_expression_res_df.csv")




res_df_nuc_cyto <- data.frame("gene_id" = character(), 
                     "baseMean" = numeric(), 
                     "log2FoldChange" = numeric(), 
                     "lfcSE" = numeric(),
                     "stat" = numeric(),
                     "pvalue" = numeric(),
                     "padj" = numeric(),
                     "gene_name" = character(),
                     "result_name" = character())









```













# DESeq with all subcellular fractions

```{r}
samplesheet <- read_csv("rnaseq/samplesheet.csv")

# We of course need to swap the labels for total and insoluble cytoplasmic
# From looking in the browser at genes that should be nuclear: NEAT1 for ex.
# We have concluded that 
# hepg2_R2 -- is whole cell / total
# hepg2_insoluble_cytoplasmic_fraction_R2 -- is whole cell / total
# hepg2_R1 -- is insoluble_cytoplasmic
# hepg2_insoluble_cytoplasmic_fraction_R1 -- is insoluble_cytoplasmic

# The cleanest thing to do would be to fix it on the design file and re-run the nf-core pipeline,
# but for now we can swap it here.
samplesheet[which(samplesheet$sample_name == "hepg2_R1"), "condition"] <- "insoluble_cytoplasmic_fraction"
samplesheet[which(samplesheet$sample_name == "hepg2_insoluble_cytoplasmic_fraction_R2"), "condition"] <- "total"
```

```{r}
# We now won't filter the sample sheet and we'll read in all the data
files <- file.path("rnaseq/results/star_salmon",
                   samplesheet$sample_name, 
                   "quant.sf")
names(files) <- samplesheet$sample_name

txi <- tximport(files, type = c("salmon"), tx2gene = tx2gene)
```

```{r}
# We'll do the same housekeeping as before to make sure the genes and the samples are in the same order as
# the count data.
names(genes) <- genes$gene_id
genes <- genes[rownames(txi$counts)]
stopifnot(all(genes$gene_id == rownames(txi$counts)))

# Create rownames for the sample sheet and then use that to re-order
samplesheet <- samplesheet %>%
  mutate(row_names = sample_name) %>%
  column_to_rownames("row_names")
samplesheet <- samplesheet[colnames(txi$counts),]
stopifnot(all(rownames(samplesheet) == colnames(txi$counts)))
```

```{r}
# In order to make the total (whole cell) condition be the one that everything is compared back to
# we will want to set the factor levels with "total" first
samplesheet$condition <- factor(samplesheet$condition, levels = c("total", "membrane_fraction", 
                                                                  "insoluble_cytoplasmic_fraction", 
                                                                  "cytosolic_fraction", "nuclear_fraction"))

dds <- DESeqDataSetFromTximport(txi,
                                design = ~ condition,
                                colData = samplesheet,
                                rowData = genes)

# Run the DESeq stats
dds <- DESeq(dds)
```

```{r}
# We now have a bunch more results
resultsNames(dds)

# Let's just look at one of the results


res <- results(dds, name = "condition_membrane_fraction_vs_total")

res_shrunken <- lfcShrink(dds, coef = "condition_membrane_fraction_vs_total",  res = res)


# Let's quickly compare the unshrunken vs shrunken fold changes.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

# Set the x-axes the same.
summary(res_df$log2FoldChange)

ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)


res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

ggplot(res_shrunken_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)
```

```{r}
# Okay, now that we have results for each comparison back to total,
# we can combine the fold changes into a matrix and make a heatmap / cluster the genes
# By which cellular fraction they are enriched in.
# A good starting point would be to use a for loop to make a data.frame with all the results
# and then you can make that into a matrix with pivot_wider.
results_names <- resultsNames(dds)
# We don't care about the intercept, so we can leave that out
results_names <- results_names[-1]

res_df <- data.frame("gene_id" = character(), 
                     "baseMean" = numeric(), 
                     "log2FoldChange" = numeric(), 
                     "lfcSE" = numeric(),
                     "stat" = numeric(),
                     "pvalue" = numeric(),
                     "padj" = numeric(),
                     "gene_name" = character(),
                     "result_name" = character())

res_shrunken_df <- data.frame("gene_id" = character(), 
                              "baseMean" = numeric(), 
                              "log2FoldChange" = numeric(), 
                              "lfcSE" = numeric(),
                              "stat" = numeric(),
                              "pvalue" = numeric(),
                              "padj" = numeric(),
                              "gene_name" = character(),
                              "result_name" = character())


for(i in 1:length(results_names)) {
  results_name <- results_names[i]
  res <- results(dds, name = results_name)
  res_shrunken <- lfcShrink(dds, coef = results_name,  res = res)
  
  tmp_res_df <- res %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  
  tmp_res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  # Append to full data.frame
  res_df <- bind_rows(res_df, tmp_res_df)
  res_shrunken_df <- bind_rows(res_shrunken_df, tmp_res_shrunken_df)
}

# Let's move forward with the shrunken log fold-changes
# First let's label the genes as being significant in any condition or not.
res_shrunken_df <- res_shrunken_df %>%
  group_by(gene_id) %>%
  mutate(sig = ifelse(any(padj < 0.05), "sig", "ns"))

# Let's clean up the column names a little bit
res_shrunken_df <- res_shrunken_df %>%
  mutate(subcellular_fraction = gsub("condition_|_fraction_vs_total", "", result_name))

sig_res_shrunked_df <- res_shrunken_df %>%
  filter(sig == "sig")

lfc_matrix <- sig_res_shrunked_df %>% 
  dplyr::select(gene_id, log2FoldChange, subcellular_fraction) %>% 
  pivot_wider(names_from = "subcellular_fraction", values_from = "log2FoldChange") %>%
  column_to_rownames("gene_id") %>%
  as.matrix()

pheatmap::pheatmap(lfc_matrix, show_rownames = FALSE, breaks = seq(-3, 3, length.out = 100))
```
