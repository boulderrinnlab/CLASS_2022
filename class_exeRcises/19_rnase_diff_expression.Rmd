---
title: "19_Rnaseq_diff_expression"
author: "JR"
date: "10/11/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(tidyverse)
library(tximport)
library(DESeq2)
library(ggrepel)
library(pheatmap)

source("../../../util/plotting_functions.R")
source("../../../util/_setup.R")
```

Today we will performing differential expression on HEPG2 RNAseq data. We will focus on comparing nuclear versus cytoplasmic RNAs. We can use this data to find genes that are nuclear or cytoplasmic enriched. We can use this data to determine if the high-binding promoters are biased for nuclear or cytoplasmic RNAs. Meaning the number of binding events indicates if the RNA product is sent to the cytoplasm (typically) or the nucleus. We can also use this data to determine if lncRNAs or mRNAs have similar or different nuclear/cytoplasmic localizations.



First let's read in th sample sheet in our data folder
```{r import sample sheet}
samplesheet <- read_csv("/scratch/Shares/rinnclass/CLASS_2022/data/samplesheet.csv")

# ENCODE swapped labels on one sample !! 

# We of course need to swap the labels for total and insoluble cytoplasmic
# From looking in the browser at genes that should be nuclear: NEAT1 for ex.
# We have concluded that 
# hepg2_R2 -- is whole cell / total
# hepg2_insoluble_cytoplasmic_fraction_R2 -- is whole cell / total
# hepg2_R1 -- is insoluble_cytoplasmic
# hepg2_insoluble_cytoplasmic_fraction_R1 -- is insoluble_cytoplasmic

# Long story let's just fix it.

samplesheet[which(samplesheet$sample_name == "hepg2_R1"), "condition"] <- "insoluble_cytoplasmic_fraction"
samplesheet[which(samplesheet$sample_name == "hepg2_insoluble_cytoplasmic_fraction_R2"), "condition"] <- "total"

# saving this to sample_sheets folder

write.csv(samplesheet, "sample_sheets/full_samplesheet_corrected.csv")

# We will want a nuclear versus cytoplasmic sample_sheet too so let's filter:

samplesheet_filtered <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))
```

Now let's read in the genome features also in our data folder
While we are at it, let's also print these out to make this go quicker in the future.
```{r import genome features}

# Importing genome annotations
gencode_gtf <- rtracklayer::import("/scratch/Shares/rinnclass/CLASS_2022/data/gencode.v32.annotation.gtf")
# that took awhile let's make genome annotation files that can be quickly read in the future


# Let's reduce this big GRanges list to just genes
genes <- gencode_gtf[gencode_gtf$type == "gene"]


# let's make an object of gene_id and names
# we just saw above we can get both gene_id and name from 'genes'
# We can convert to DF for readability.

g2s <- genes %>% as.data.frame() %>%
  dplyr::select(gene_id, gene_name)

write.csv(g2s, "g2s.csv")

# Nice now we have a handy conversion table of gene_id & gene_name
```

Ok, next step is to read in GENE COUNTS (not TPM) This was exported from the NF_CORE RNAseq pipeline in the salmon folder. We want "salmon_merged_gene_counts.csv
```{r reading in salmon counts convert to matrix}

# DEseq requires a matrix of raw counts
counts <- read_csv("/scratch/Shares/rinnclass/CLASS_2022/data/rnaseq/results/salmon/salmon_merged_gene_counts.csv") %>%
  # this will remove the gene_id column and use it as 'meta' data in matrix
  column_to_rownames("gene_id") %>%
  as.matrix()

# Nice now we have a matrix we need to import to DeSeq
# However it has all the samples so we need to orgnize a bit.
```

Making an rlog counts matrix for all samples -- can read in to start in future
```{R making counts table and normalized Rlog counts}

# First let's put the counts columns in the same order as the samplesheet
# If they are not then we would essentially be randomizing our data later!!

counts <- counts[,samplesheet$sample_id]

# This is a handy check point to make sure the labels in 
# sample sheet and counts are similar

all(colnames(counts) == samplesheet$sample_id)

# Now we know they're in the same order, and we can change the names

colnames(counts) <- samplesheet$sample_name

# Deseq wants round numbers so we are going to round them here:

counts <- round(counts)

# now we want to get rid of all genes with 0 across all samples.

counts_filtered <- counts[rowSums(counts) > 1,]


# Next we want to normalize these counts 
# mostly to account for low abundance and noisey genes
# We need to do this in four steps:

# (1) first run DESeq2 by creating a dds object.

dds <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = samplesheet,
                              design = ~ condition)

# (2) run DESeq2 on dds object

dds <- DESeq(dds)

# (3) arrive at rlog normalized counts table!
# bild = T means it will normalize with out the "design ~ condition"
# seems redundant but these are the steps :)

rlog_counts <- rlog(dds, blind = TRUE)

# (4) now we retrieve the values using assay (an accessor function into rlog_counts)

rlog_counts_matrix <- assay(rlog_counts)

# Let's round the numbers now for better storage of this data

rlog_counts_matrix <- round(rlog_counts_matrix)


# Now we can write this out and START from here in the future.

write_rds(rlog_counts_matrix, "rlog_count_matrices/rlog_counts_all_rounded.rds")

# reading back in to be sure we can start here in the future.
rlog_counts_matrix <- read_rds("rlog_count_matrices/rlog_counts_all_rounded.rds")
```


Now let's make a sample sheet we can use to compare nuc/cyto samples.
```{R nuclear and cytoplasmic samplesheet}
# Now we will filter the sample sheet to just nuclear and cytoplasmic

samplesheet_filtered_nuc_cyto <- samplesheet %>%
  filter(condition %in% c("cytosolic_fraction", "nuclear_fraction"))

# Nice now we have a reduced sample sheet that is well organized.

# Next, let's triple check that the reduced sample sheet and counts
# have the same sample names.

samplesheet_filtered_nuc_cyto$sample_name %in% colnames(counts)

# Cool, the 4 samples in filtered are same as counts
# Now let's look at samplesheet_filtered.
# Not the rownames are numbers -- this is 'meta' information we need.
# So let's make the rownames the names of the samples.

rownames(samplesheet_filtered_nuc_cyto) <- samplesheet_filtered_nuc_cyto$sample_name
# Now if we look at this object we see rownames as sample_name - nice.

# let's write out this samplesheet for future use

write.csv(samplesheet_filtered_nuc_cyto, "sample_sheets/samplesheet_filtered_nuc_cyto.csv")

```


Next we will reduce out counts_matrix to just the values of nuc/cyto
```{r nuc/cyto  counts}

# first reduce the counts matrix to just these 4 samples.
counts_nuc_cyto <- counts[, samplesheet_filtered$sample_name]

# This is a good way to triple check everything is in order.

stopifnot(all(rownames(samplesheet_filtered) == colnames(counts_nuc_cyto)))
# Great this evaluated to true and thus moved on -- we would get an error message otherwise.

```

We are almost ready, last things to check:

DeSeq2 requires integer data and that condition is a factor. We will make
sure these data files are in the right data format (good example of data types in R!)

Most importantly we need to add a 'meta' factor for DeSeq to know which order the samples
were analyzed -- this is critical !! Log fold change doesn't mean much with out knowing the order.
```{R organizing nuc/cyto counts and samplesheet for deseq}

# NOTE: DeSeq wants the control as a factor (fct), currently (chr)
# The first factor level is the "control" and all the other levels
# will be compared back to it.

# Let's make the condition a factor:

samplesheet_filtered$condition <- factor(samplesheet_filtered$condition, 
                                         levels = c("nuclear_fraction", "cytosolic_fraction"))

# now we see condition became a factor!
# So now a log fold change of < 1 = cytosolic, and greater than 1 = nuclear.
# This is subtle but important.

# Ok now we need to turn the counts into integer data (int)

counts <- round(counts_nuc_cyto)
# This will round the counts, but still need to change to integer

mode(counts_nuc_cyto) <- "integer"
# We just coerced the data to integer and can now see that in env (int).

# Ok, one final step filtering some of the gene counts out.
# Let's fileter to genes that have at least one count across cols.
nuc_cyto_counts_filtered <- counts[rowSums(counts) > 1,]

```


Ok we are now ready for 'DeSeq land' we will be calling several
functions from DeSeq. We need to know a few things that DeSeq requires.
We will explore these now.
```{R}

# we dirst set up a dds (Distributed Data-structures in R)
# we have created a count matrix and thus will use 'DESeqDataSetFromMatrix'
# the params for this are:
# 'countData' (the counts matrix)
# 'coldData' where to get column data for which samples are which 
# design is the analysis model and we are using condition column in sample sheet.


dds <- DESeqDataSetFromMatrix(countData = nuc_cyto_counts_filtered,
                              colData = samplesheet_filtered,
                              design = ~ condition)

# after creating the dds we run the DESeq function on this dds.
# NOW WE RUN DESEQ !!

dds <- DESeq(dds)

# Now let's get the rlog normalized nuc/cyto counts like we did above
# running rlog normalization on dds (that is only nuc and cyto now)
# CAREFUL of what is in your dds when running this part :)

rlog_counts_nuc_cyto <- rlog(dds, blind = TRUE)

# exctracting count matrix with assay()

rlog_counts_matrix_nuc_cyto <- assay(rlog_counts)

# This is another handy matrix to load in so let's write it out

write_rds(rlog_counts_matrix_nuc_cyto, "rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

# reading in so comfortable starting here with nuc/cyto

rlog_counts_matrix_nuc_cyto <- read_rds("rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

# Nice now we can just start here in the futre.
```

# START POINT
All the work we have done above can be skipped by 
reading in the following files.

```{r START POINT}

# All normalized counts 
rlog_counts_matrix <- read_rds("rlog_count_matrices/rlog_counts_all_rounded.rds")

# Nuc/cyto normalized counts.
rlog_counts_matrix_nuc_cyto <- read_rds("rlog_count_matrices/rlog_counts_matrix_nuc_cyto.rds")

# full sample_sheet
samplesheet <- read_csv("sample_sheets/full_samplesheet_corrected.csv")

# nuc/cyto sample sheet
samplesheet_filtered_nuc_cyto <- read.csv("sample_sheets/samplesheet_filtered_nuc_cyto.csv")

# need to add row names
rownames(samplesheet_filtered_nuc_cyto) <- samplesheet_filtered_nuc_cyto$sample_name

# finally a gene_id and gene_names object

g2s <- read.csv(g2s, "g2s.csv")

```


Now let's cluster the data of differntially expressed genes in nuc/cyto.
```{R heat map of differnetial genes in nuc_cyto}
# first let's filter to variable genes 

hist(rowVars(rlog_counts_matrix_nuc_cyto))

# Based on this we see that most of the data is 0 or not differential across samples.
# somewhere around 2 the distribution changes so let's filter there:

rlog_var_genes_nuc_cyto <- rlog_counts_matrix_nuc_cyto[rowVars(rlog_counts_matrix_nuc_cyto) > 2,]
# cool we have the top 1,000 ish genes that are variable between nuc/cyto.

# Now we need to "row center" the values across samples. This simply means:
# we take the mean of the row and divide it by each value. Tells where up and down.

# r can only scale in columns so we are going to transmute the matrix (counts as cols)
# then flip the matrix right back

scaled_counts_nuc_cyto <- t(scale(t(rlog_var_genes_nuc_cyto)))

# Nice and for all this hard work, how about a heatmap:

pheatmap(scaled_counts_nuc_cyto, show_rownames = FALSE)
# Awesome that looks just as it should let's save it!

pdf("figures/nuc_cyto_var_genes_heatmap.pdf")
pheatmap(scaled_counts_nuc_cyto, show_rownames = FALSE)
dev.off()


# Now we can make a heatmap of all the data too
rlog_var_genes <- rlog_counts_matrix[rowVars(rlog_counts_matrix_nuc_cyto) > 2,]

# row center
scaled_counts <- t(scale(t(rlog_var_genes)))

# make heat map
pheatmap(scaled_counts, show_rownames = FALSE)

# saving
pdf("figures/nuc_cyto_var_genes_heatmap.pdf")
pheatmap(scaled_counts, show_rownames = FALSE)
dev.off()

```


The clustering showed a clear separation of nuc and cyto samples.
Now let's see how similar and different the samples and replicates are.
To do this we will use Principle Component Analysis (PCA)
```{r PCA analysis}

#TODO something buggy here

# The first thing that we'll want to do is make a PCA plot.
# 'prcomp()' is the principle component analysis function.

?prcomp


rld_pca <- prcomp(t(assay(rlog_counts)))
rld_prcomps <- rld_pca$x %>% as.data.frame() %>%
  # note that x is in rld_pca as the PCA values
  rownames_to_column("sample_name") %>%
  select(sample_name, PC1, PC2)
rld_prcomps <- merge(samplesheet, rld_prcomps)
# install.packages("ggrepel")


ggplot(rld_prcomps, aes(x = PC1, y = PC2, color = condition, label = replicate))
geom_point() +
geom_text_repel()

```

Now let's look deeper into the results held in dds object
```{r digging deeper into dds}

# let's check out dds
resultsNames(dds)

# not very interesting because it's an DESeq object.
# 'results' is a DESeq function that can extract results.
# ?results

res <- results(dds, name = "condition_cytosolic_fraction_vs_nuclear_fraction")

# It's easier to view it as a data.frame so we'll convert it.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s)

# Nice now we have a DF with a lot of good info for each gene.
```

Let's make some standard RNAseq or gene-expression plots:
```{r volcano, MA and other plots}

# First let's take a look at res_df
# What is the most nuclear RNA? Most cytoplasmic? Does that make sense?

# Now we can look at the data with some standard QC plots:

#TODO add color (color by noncoding or not?)
# Volcano plot
ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = -log10(padj > 90))) + 
  geom_point()


# MA plot (this make a take a min)
ggplot(res_df, aes(x = log10(baseMean), y = log2FoldChange)) + 
  geom_point()

# This is a good QC plot and shows the pvalues are not biased to low "base-mean" levels

# let's see the range of pvalues:
hist(res_df$padj)

# how many genes above 0.05 padj?

num_sig <- res_df$padj < 0.05
summary(num_sig)

# We see about 14,268 genes are differentiall expressed.
```


Let's now save res_df as a data.frame of genes differential 
in nuc -vs -cyto with P < 0.05

```{r}

# Let's save this dataframe !!
write.table(res_df, "results/nuc_cyto_diff_expression_res_df_P05.csv")






#TODO why this?

res_df_nuc_cyto <- data.frame("gene_id" = character(), 
                     "baseMean" = numeric(), 
                     "log2FoldChange" = numeric(), 
                     "lfcSE" = numeric(),
                     "stat" = numeric(),
                     "pvalue" = numeric(),
                     "padj" = numeric(),
                     "gene_name" = character(),
                     "result_name" = character())

test <- read.table("results/nuc_cyto_diff_expression_res_df.csv")

```




# DESeq with all subcellular fractions

```{r organizing sample sheet for comparison to total RNA for each fraction}


#TODO figure out what to load in here :(
samplesheet <- read_csv("sample_sheets/full_samplesheet_corrected.csv")


# In order to make the total (whole cell) condition be the one that everything is compared back to
# we will want to set the factor levels with "total" first

samplesheet$condition <- factor(samplesheet$condition, levels = c("total", "membrane_fraction", "insoluble_cytoplasmic_fraction", "cytosolic_fraction", "nuclear_fraction"))


#TODO how to read this in? Is this the right counts?
# reading in all counts:
rlog_counts_matrix <- read_rds("rlog_count_matrices/rlog_counts_all_rounded.rds")


dds <- DESeqDataSetFromMatrix(countData = rlog_counts_matrix,
                              colData = samplesheet,
                              design = ~ condition)

# setting up dds for DESeq
dds <- DESeqDataSetFromTximport(rlog_counts_matrix,
                                design = ~ condition,
                                colData = samplesheet,
                                rowData = g2s)

# Run the DESeq stats
dds <- DESeq(dds)


```





```{r}
# In order to make the total (whole cell) condition be the one that everything is compared back to
# we will want to set the factor levels with "total" first
samplesheet$condition <- factor(samplesheet$condition, levels = c("total", "membrane_fraction", 
                                                                  "insoluble_cytoplasmic_fraction", 
                                                                  "cytosolic_fraction", "nuclear_fraction"))

dds <- DESeqDataSetFromTximport(txi,
                                design = ~ condition,
                                colData = samplesheet,
                                rowData = genes)

# Run the DESeq stats
dds <- DESeq(dds)
```

```{r}
# We now have a bunch more results
resultsNames(dds)

# Let's just look at one of the results


res <- results(dds, name = "condition_membrane_fraction_vs_total")

res_shrunken <- lfcShrink(dds, coef = "condition_membrane_fraction_vs_total",  res = res)


# Let's quickly compare the unshrunken vs shrunken fold changes.
res_df <- res %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

# Set the x-axes the same.
summary(res_df$log2FoldChange)

ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)


res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  merge(g2s) %>%
  mutate(result_name = "condition_membrane_fraction_vs_total")

ggplot(res_shrunken_df, aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() + xlim(-24, 13)
```

```{r}
# Okay, now that we have results for each comparison back to total,
# we can combine the fold changes into a matrix and make a heatmap / cluster the genes
# By which cellular fraction they are enriched in.
# A good starting point would be to use a for loop to make a data.frame with all the results
# and then you can make that into a matrix with pivot_wider.
results_names <- resultsNames(dds)
# We don't care about the intercept, so we can leave that out
results_names <- results_names[-1]

res_df <- data.frame("gene_id" = character(), 
                     "baseMean" = numeric(), 
                     "log2FoldChange" = numeric(), 
                     "lfcSE" = numeric(),
                     "stat" = numeric(),
                     "pvalue" = numeric(),
                     "padj" = numeric(),
                     "gene_name" = character(),
                     "result_name" = character())

res_shrunken_df <- data.frame("gene_id" = character(), 
                              "baseMean" = numeric(), 
                              "log2FoldChange" = numeric(), 
                              "lfcSE" = numeric(),
                              "stat" = numeric(),
                              "pvalue" = numeric(),
                              "padj" = numeric(),
                              "gene_name" = character(),
                              "result_name" = character())


for(i in 1:length(results_names)) {
  results_name <- results_names[i]
  res <- results(dds, name = results_name)
  res_shrunken <- lfcShrink(dds, coef = results_name,  res = res)
  
  tmp_res_df <- res %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  
  tmp_res_shrunken_df <- res_shrunken %>% as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    merge(g2s) %>%
    mutate(result_name = results_name)
  
  # Append to full data.frame
  res_df <- bind_rows(res_df, tmp_res_df)
  res_shrunken_df <- bind_rows(res_shrunken_df, tmp_res_shrunken_df)
}

# Let's move forward with the shrunken log fold-changes
# First let's label the genes as being significant in any condition or not.
res_shrunken_df <- res_shrunken_df %>%
  group_by(gene_id) %>%
  mutate(sig = ifelse(any(padj < 0.05), "sig", "ns"))

# Let's clean up the column names a little bit
res_shrunken_df <- res_shrunken_df %>%
  mutate(subcellular_fraction = gsub("condition_|_fraction_vs_total", "", result_name))

sig_res_shrunked_df <- res_shrunken_df %>%
  filter(sig == "sig")

lfc_matrix <- sig_res_shrunked_df %>% 
  dplyr::select(gene_id, log2FoldChange, subcellular_fraction) %>% 
  pivot_wider(names_from = "subcellular_fraction", values_from = "log2FoldChange") %>%
  column_to_rownames("gene_id") %>%
  as.matrix()

pheatmap::pheatmap(lfc_matrix, show_rownames = FALSE, breaks = seq(-3, 3, length.out = 100))
```
