---
title: "11_R_functions"
author: "JR"
date: "10/18/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GenomicRanges)
source("../util/intersect_functions.R")
source("../util/class_functions.R")
```

First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. 

We have used many of R's built in base functions that require parameters too.For example,table and summary we used before requires a parameter of an object to summarize etc.But the cool part is you can make your own functions just like these base R funcitons. 

Now, let's see what it looks like in R. A common function in life is math -- it takes inputs and maps it to outputs.
```{r}
# This function has two parameters, and we have to let R know (x & y)
# function is inside { }, then we need a 'return' to get the answer

fun <- function(x, y) {
  ans <- x * y
  return(ans)
}
fun(2,-4)

# Note that the object ans doesn't exist in our environment. 
# ans is a local variable that is erased after used. global variables are in our environment.
# It's good to remember the "scope" of vars in a function don't really exist outside the function.
# Finally note a function can only return one thing!
```



When creating a function, you can also add documentation about what that function 
does and the data types and expectationn for the the parameters it takes.
```{r}
#' A function to multiply two numbers
#'
#' @description 
#' This function will multiply the input values of X and Y
#' 
#' @param x one number you'd like to multiply
#' y the other number you'd like to multiply
fun <- function(x, y) {
  ans <- x * y
  return(ans)
}

# Let's make a util .R file and put this function in there
# clear environment and load functions -- shows up as something you can just run now
# Note that the documentation is present in the little "note" icon link.
```

Now let's understand "scope" better by creating a more complex function. 

Local variables are those variables that exist only within a certain part of a program 
like a function and are released when the function call ends.

So it's good to remember local variables are mapped to outputs through a function, but 
only exist within a function.

Let's take a look at a more complex function we may want to routinely use.

One common task is to make a list of files to be analyzed and rename them based on information
in the file name itself. Let's look at this function:

```{r}

# First let's set a file path to where all our peak files are.

broadpeakfilepath <- paste0("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")

# So this is now a global variable that can be called in a function.

  fl <- list.files(broadpeakfilepath, 
                   full.names=TRUE)
  # making a list of file names as we did in 08.Rmd Note full file path is included
  # This gives us an index 1-15 where each peak file is in a vector.
  
  fl <- fl[grep("peaks.broadPeak", fl)]
  # making sure we only get files that are .broadPeak using grep
  
```

Let's make a function to find which DBPs have peak files. sapply requires a function so let's try it
```{R} 

  tf_name <- sapply(fl, function(x){
    y <-  str_extract(x, "([^\\/]+$)")
    unlist(strsplit(y, "_"))[[1]]
    
    # We use a generic function (function(x) and set a new variable y using str_extract
    # then x is subject to str_extract and regex to split all / and words (https://regexr.com/3cr6f)  
    # strplit then splits up the broken up string from str_extract and takes the right side 
        # first character string after the last /
    
    # ?? What would the input be to make this a function ??

  })
```

Ok let's make this into a real function that is re-usable "import_peaks" and name file by DBP

```{R}

# estbalishing the function using "function()"
# establishing the parameter consensus_file_path is needed

import_peaks <- function(consensus_file_path = "/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise") {
  
  # Setting some variables needed in main part of function (same as above -- peak_files & tf_name)
  peak_files <- list.files(consensus_file_path, full.names = T)
  tf_name <- sapply(peak_files, function(x){
    y <-  str_extract(x, "([^\\/]+$)")
    unlist(strsplit(y, "_"))[[1]]
  })

# Here is the heart of the function that will import each file as GRanges (we can use for overlaps)
  
  peak_list <- c()
  for(i in 1:length(peak_files)) {
    # Import peak files
    peaks <- rtracklayer::import(peak_files[i])
    # Append this GRanges object to the of the list.
    peak_list <- c(peak_list, peaks)
    # Name the list elements by their TF name.
    names(peak_list)[length(peak_list)] <- tf_name[i]
  }
  return(peak_list)
}

# ?? Why did nothing come back in the global environment ??

```


Let's use import_peaks function but assign the local output to global output!
```{R}
peak_lists <- import_peaks("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")
```
 
 Let's add import peaks to util using this header:
```{R}


#' import peak .bed files as a list
#' 
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files
```

Cool now we have a function to import peak files as a GRanges.
We can now use this to find overlaps using another function "intersect peaks"



 
 
 
 
 
 
 
 
 
 
 

Now let's look at the functions involved in creating consensus peaks.
```{r}
#' intersect replicates into a "consensus peak list" 
#' 
#' @description 
#' this function will take the  union of peak widths across replicates for a given
#' DNA binding protein. the function that will take a list of granges objects and return 
#  one granges object with merged peaks that are in all replicates
#' 
#' @param 
#'  the path to consensus peak files
#' # We're going to iterate over all the files to make it work. 
```



```{r}

 peak_list <- c()
    for(j in 1:length(tf_files)) {
      # See the read peaks function to know what subfunctions are called.
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }

intersect_peaks <- function(peak_list) {
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
  }
  return(combined_peaks)
}


```










Let's go over a customfunction we already wrote. The goal of this function is to take
replicate ChIPseq .broadPeak files and find all the peaks that overlap. Then reduce them.

Below we will go through each step of the create_consensus_peaks function that occurs in between { }.
```{R}

# Normally, we would just run the function with this filepath below.

consensus_peaks <- create_consensus_peaks("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise/")

# Simple as that we get all overlapping peaks

```

Now if we were going to make a new function (HINT THIS IS KEY FOR EXERCISE)!!
We would assign the function name like this below

```{R}

create_consensus_peaks <- function(broadpeakfilepath = "/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise/")
{
  
  # FUNCTION GOES IN HERE
  
  }
  
```

Since the only parameter needed is the boradpeakfilepath we will set that and move along the function.
These are new R functions being used:

'function(x)' a genertic function that will be used to work on x in str_extract
'str_extract' (that extracts the information of character vector of file names) this will be set to y.
strsplit
```{R}

broadpeakfilepath <- paste0("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")

  fl <- list.files(broadpeakfilepath, 
                   full.names=TRUE)
  # making a list of file names as we did in 08.Rmd
  
  fl <- fl[grep("peaks.broadPeak", fl)]
  # making sure we only get files that are .broadPeak using grep
  
  tf_name <- sapply(fl, function(x){
    y <-  str_extract(x, "([^\\/]+$)")
    unlist(strsplit(y, "_"))[[1]]
    
    # This is regex to grab the DBP name (TF_name) from the file list
    # Let's look up the regex in regex-translator (https://regexr.com/3cr6f)   
    

  })
  
  # Basically we just took the file names and extracted the name of DBP in "tf_name" object
  # note strsplit is indexed to [[1]] this takes the right side of the split and [0] the left side
  
```

We have replicate peak files so we will make an index for each unique DBP to group replicates by.  
First let's filter files that don't have replicates.
```{R}


# This is a handy use of table to get individual names and filter to get those with more than 1 file.
  tf_df <- data.frame(table(tf_name)) %>%
    filter(Freq > 1)

# Now let's make a list of unique DBP names (unique_tf)
    unique_tf <- as.character(tf_df$tf_name)

```


Now we are getting into a major for loop that will read each unique DBP (unique_tf)
We start by making an empty list with 'list()'
The for loop will populate this list with each peak file for a give DBP.
```{R}
  
  consensus_peaks <- list()
  # This for loop will iterate over all individual peak files for a given DBP name (unique_tf).
  for(i in 1:length(unique_tf)) {
    tf <- unique_tf[i]
    print(tf)
    # This will allow us to keep track of what is happening in counsel.
    tf_index <- grep(tf, tf_name)
    # note TF name has all the indexing for each replicate
    tf_files <- fl[tf_index]

}
# Cool, so we have made a tf_files list that has the peak file path and tf_index of where that is in tf_name.

# Now we need to make a peak list of all the .broadPeak files associated with each DBP (tf_name)
# We will use tf_files since it has the direct file path to the peak files.


    peak_list <- c()
    for(j in 1:length(tf_files)) {
      # See the read peaks function to know what subfunctions are called.
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }




# Let's filter to normal chromosome entries for ease moving forward (similar to what we did 08)

    canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
    for(i in 1:length(peak_list)) {
      peak_list[[i]] <-peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
    }
    
  
    final_peakset <- intersect_peaks(peak_list = peak_list)
    if(length(final_peakset) > 0) {
      final_peakset$name <- paste0(tf, "_", 1:length(final_peakset))
    }
    
    consensus_peaks <- c(consensus_peaks, list(final_peakset))
    names(consensus_peaks)[length(consensus_peaks)] <- tf
  }

# TODO: refactor
read_peaks <- function(broad_peak_file, filter_to_canonical_chr = TRUE) {
  # A broad peak file is just a tab separated file 
  dat <- read.table(broad_peak_file, sep = "\t")
  if(filter_to_canonical_chr == TRUE) {
    dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
  }
  gr <- GRanges(seqnames = dat$V1,
                ranges = IRanges(start=dat$V2,end=dat$V3))
  return(gr)
}
# This is the function that will be doing the core of the work here. 
# When two peaks intercept, we will take their outer boundaries to be the new
# peak -- using the reduce function.
intersect_peaks <- function(peak_list) {
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
  }
  return(combined_peaks)
}
```

*********************
EXCERCISE
*********************

Create a function to:

Format .broadPeak files for UCSC and put into Util folder

Hint you have already done most of the work :)

You can call it whatevr you want and set parameters etc.











Here is some more markdown to go over what is happening with this function.
```{r}
create_consensus_peaks <- function(broadpeakfilepath = "/scratch/Shares/rinnclass/data/peaks") {
  
  fl <- list.files(broadpeakfilepath, 
                   full.names = TRUE)
  
  
  # fl <- fl[grep("broadPeak", fl)]
  #This is for safety if you want to grab the right file type from 'macs' output.
  
  # Let's subset this data for testing
  # In practice you'll want to run this on the full dataset.
  fl <- fl[1:20]
  
  # fl: this is just going to be a list of the peak file names
  # this used the R function "list.files" -- take a look:
  # ?list.files
  # So we have now read in all the file names in the paramater path.
  
  
  ## Here we are reading in files first again and putting them in the object "create_consensus_peaks"
  ## We are using grep to just grab broadPeak files. This is because the macs folder has many different
  ## versions of peak files. It is just useful to be sure it grabs the right file type.
  ## In our case the folder all_peak_files is only broadPeak files so a bit redundant....for safety.
  
  tf_name <- sapply(fl, get_dbp_name)
  
  ## Here we just named the file with str_extract and regex.
  # ?str_extract (need tidyverse library loaded)
  # The paramaters are:
  
  # string: the input vector of coerciable data (e.g. character string) -- peak_files
  # here we are using x that is being read in by the function which is an individual file name.
  
  
  #pattern: the pattern to look for across the input vector. this is using regular
  # expression (regex). You don't need to know this much regex, but if you are ever 
  # curious you can use the online regex calculator :)
  # 
  # https://regexr.com/
  # 
  # if you paste in the two regex commands below it will tell you what they are looking for.
  
  ## Now our goal is to associate the replicate files with a unique DBP name. So 
  ## 'unique_tf' will only provide one DBP name -- but will later be associated with
  ## each replicate file associated with that DBP name.
  
  unique_tf <- unique(tf_name)
  
  ## ?unique
  ## here we see the unique function provide information to index each DBP as a unique 
  ## entry.
  
  
  consensus_peaks <- list()
  
  # This for loop will iterate over all dna binding proteins.
  for (i in 1:length(unique_tf)) {
    # this is why we set up unique_tf above so the for loop will only run on one DBP
    # at a time, and merges the peaks of the replicate files associated with each DBP.
    # then the for loop will move onto the next unique_tf and merge those peak files.
    
    dbp <- unique_tf[i]
    
    cat("Now I'm running", dbp, "\n")
    # this is just a fun way of seeing the progress of the for loop -- also good
    # for debugging when a file fails -- you know the last successful run.
    
    tf_files <- fl[grep(dbp, fl)]
    # here we are creating dbp to use in grep to grab the dbp entry and find it in fl
    # this way we only intersect the replicate files that have the same dbp name.
    # this is why we indexed into unique_tf[i]. Then the next unique DBP name will
    # run in the next iteration of the loop.
    if (length(tf_files) > 1) {
      # turns out some files don't have replicates :( so we are saying here that if
      # the current (i) entry for 'tf_files' is equal or less than 1 to stop running.
      # we can't intersect peaks if there is only one peak file :)
      
      peak_list <- c()
      # making a new object peak list that will be populated by the loop below.
      # we leave it empty until the loop runs by simpling putting c()
      
      for (j in 1:length(tf_files)) {
        ## This for loop is going to go through each peak file and store it in peak_list
        
        peak_list <- c(peak_list, read_peaks(tf_files[j]))
      }
      
      # read_peaks is a function we already made in .util. It's pretty basic and 
      # commented out below
      
      # read_peaks <- function(broad_peak_file, filter_to_canonical_chr = TRUE) {
      
      # dat <- read.table(broad_peak_file, sep = "\t")
      # if(filter_to_canonical_chr == TRUE) {
      # dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
      # }
      # gr <- GRanges(seqnames = dat$V1,
      # ranges = IRanges(start=dat$V2,end=dat$V3))
      #return(gr)
      #}
      
      ## Read peaks is a good example of 'ranges' in action. notice the redundant cleaning up
      ## to cannonical chromosomes (which is also below).
      
      ## Setting up peak_list and printing 'c()' the information of read_peaks for a unique
      ## DBP that we set up above. This will result in read_peaks reading in the peaks from 
      ## the replicate files in tf_files will both be read in.
      
      
      canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
      # we are using paste0 to make a list of chr1 - chr22 and chrM etc
      # these are the only chromosomes we want so setting this up for below
      
      for (i in 1:length(peak_list)) {
        peak_list[[i]] <- peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
      }
      
      ## This for loop is going to look throuhg the peak_list and retreive only the
      ## seqnames 'which' (?seqnames) that are %in% (handy r function!) our cannonical chr list.
      final_peakset <- intersect_peaks(peak_list = peak_list)
      ## intersect peaks is a function we made in the util folder intersect_functions.R
      ## It basically uses the genomicRanges package findOverlaps that does the bulk 
      ## of the intersecting peaks between files in 'peak_files'
      ## the only parameter this function needs is the peak list object (they are named the same)
      ## Here is the intersect_peaks function below
      
      #    intersect_peaks <- function(peak_list) {
      #     combined_peaks <- peak_list[[1]]
      #     for(i in 2:length(peak_list)) {
      #     suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
      #   pl1 <- combined_peaks[unique(pl_ov@from)]
      #   pl2 <- peak_list[[i]][unique(pl_ov@to)]
      #   suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
      # }
      #  return(combined_peaks)
      #}
      
      ## of note the function reduce, that is a function that will merge two overlaping
      ## ranges. We take the union of peak in list 1 and 2 (pl1, pl2). This means if they
      ## overlap it will take the furtherst ends of the ranges. 
      
      ## now we return to the for loop with an 'if' statement that will only operate
      ## if the condition of the if statement are true. Here saying the final peak list
      ## needs to be greater than 0 -- otherwise there were no peaks.
      ## if greater than 0 peaks are found it will name each peak and put it into an
      ## object final_peakset and make a new column 'name' that consists of 
      ## the DBP (or TF) name with an underscore followed by the 1 through all the peaks
      ## that are in the final_peakset of overlapping peaks.
      if (length(final_peakset) > 0) {
        final_peakset$name <- paste0(dbp, "_", 1:length(final_peakset))
      } 
      
      consensus_peaks <- c(consensus_peaks, list(final_peakset))
      names(consensus_peaks)[length(consensus_peaks)] <- dbp
      
      ## Now we are just tidying and finalizing the consensus_peaks. First concatinating
      ## consensus_peaks with all the peaks in final_peakset. The list function is 
      ## listing all the peaks in final_peakset and printing them to consensus_peaks.
      ## lastly using names to name each peak by the DBP (or TF) using <- to input the
      ## DBP name.
    }
  }
  return(consensus_peaks)
}

```


```{r}

hmmm <- read_peaks("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise/CTCF_R1_peaks.broadPeak")
```

