---
title: "11_R_functions"
author: "JR"
date: "10/18/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GenomicRanges)
source("../util/intersect_functions.R")
```

First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. 

We have used many of R's built in base functions that require parameters too.For example,table and summary we used before requires a parameter of an object to summarize etc.But the cool part is you can make your own functions just like these base R funcitons. 

Now, let's see what it looks like in R. A common function in life is math -- it takes inputs and maps it to outputs.
```{r}
# This function has two parameters, and we have to let R know (x & y)
# function is inside { }, then we need a 'return' to get the answer

fun <- function(x, y) {
  ans <- x * y
  return(ans)
}
fun(2,-4)
```

When creating a function, you can also add documentation about what that function 
does and the data types and expectationn for the the parameters it takes.
```{r}
#' A function to multiply two numbers
#'
#' @description 
#' This function will multiply the input values of X and Y
#' 
#' @param x one number you'd like to multiply
#' y the other number you'd like to multiply
fun <- function(x, y) {
  ans <- x * y
  return(ans)
}
```

This formatting above the function will compile into the nice documentation 
that you see in the help viewer pane (? fun-name). For the purposes of this class project's organization, we'll put most of the functions that we use in multiple analysis RMarkdown files, into the `../util` directory. 

Now let's look at the functions involved in creating consensus peaks.
```{r}
#' intersect replicates into a "consensus peak list" 
#' 
#' @description 
#' this function will take the  union of peak widths across replicates for a given
#' DNA binding protein. the function that will take a list of granges objects and return 
#  one granges object with merged peaks that are in all replicates
#' 
#' @param 
#'  the path to consensus peak files
#' # We're going to iterate over all the files to make it work. 
```



Let's go over a customfunction we already wrote. The goal of this function is to take
replicate ChIPseq .broadPeak files and find all the peaks that overlap. Then reduce them.

Below we will go through each step of the create_consensus_peaks function that occurs in between { }.
```{R}

# Normally, we would just run the function with this filepath below.

consensus_peaks <- create_consensus_peaks("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")

# Simple as that we get all overlapping peaks

```

Now if we were going to make a new function (HINT THIS IS KEY FOR EXERCISE)!!
We would assign the function name like this below

```{R}

create_consensus_peaks <- function(broadpeakfilepath = "/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")
{
  
  # FUNCTION GOES IN HERE
  
  }
  
```

Since the only parameter needed is the boradpeakfilepath we will set that and move along the function.
These are new R functions being used:

'function(x)' a genertic function that will be used to work on x in str_extract
'str_extract' (that extracts the information of character vector of file names) this will be set to y.
strsplit
```{R}

broadpeakfilepath <- paste0("/Shares/rinn_class/data/CLASS_2022/class_exeRcises/analysis/11_consensus_peak_exercise")

  fl <- list.files(broadpeakfilepath, 
                   full.names=TRUE)
  # making a list of file names as we did in 08.Rmd
  
  fl <- fl[grep("peaks.broadPeak", fl)]
  # making sure we only get files that are .broadPeak using grep
  
  tf_name <- sapply(fl, function(x){
    y <-  str_extract(x, "([^\\/]+$)")
    unlist(strsplit(y, "_"))[[1]]
    
    # This is regex to grab the DBP name (TF_name) from the file list
    # Let's look up the regex in regex-translator (https://regexr.com/3cr6f)   
    

  })
  
  # Basically we just took the file names and extracted the name of DBP in "tf_name" object
  
```

We have replicate peak files so this 'unique' function will reduce to unique DBPs
```{R}
  
  unique_tf <- unique(tf_name)
  # Note CTCF had 8 replicates
  # Also note only one replicate for DMAP1 (to see what happens -- will funciton error?)

```


Now we are getting into a major for loop that will read each unique DBP (unique_tf)
We start by making an empty list with 'list()'
The for loop will populate this list with each peak file for a give DBP.
```{R}
  
  consensus_peaks <- list()
  # This for loop will iterate over all indidual peak files for a given DBP name (unique_tf).
  for(i in 1:length(unique_tf)) {
    tf <- unique_tf[i]
    tf_index <- grep(tf, tf_name)
    # note TF name has all the indexing for each replicate
    tf_files <- fl[tf_index]
    
    peak_list <- c()
    for(j in 1:length(tf_files)) {
      # See the read peaks function to know what subfunctions are called.
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }
    
    canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
    for(i in 1:length(peak_list)) {
      peak_list[[i]] <-peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
    }
    
    final_peakset <- intersect_peaks(peak_list = peak_list)
    if(length(final_peakset) > 0) {
      final_peakset$name <- paste0(tf, "_", 1:length(final_peakset))
    }
    
    consensus_peaks <- c(consensus_peaks, list(final_peakset))
    names(consensus_peaks)[length(consensus_peaks)] <- tf
  }
  return(consensus_peaks)
}

# TODO: refactor
read_peaks <- function(broad_peak_file, filter_to_canonical_chr = TRUE) {
  # A broad peak file is just a tab separated file 
  dat <- read.table(broad_peak_file, sep = "\t")
  if(filter_to_canonical_chr == TRUE) {
    dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
  }
  gr <- GRanges(seqnames = dat$V1,
                ranges = IRanges(start=dat$V2,end=dat$V3))
  return(gr)
}
# This is the function that will be doing the core of the work here. 
# When two peaks intercept, we will take their outer boundaries to be the new
# peak -- using the reduce function.
intersect_peaks <- function(peak_list) {
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
  }
  return(combined_peaks)
}
```

*********************
EXCERCISE
*********************

Create a function to:

Format .broadPeak files for UCSC and put into Util folder

Hint you have already done most of the work :)

You can call it whatevr you want and set parameters etc.











Here is some more markdown to go over what is happening with this function.
```{r}
create_consensus_peaks <- function(broadpeakfilepath = "/scratch/Shares/rinnclass/data/peaks") {
  
  fl <- list.files(broadpeakfilepath, 
                   full.names = TRUE)
  
  
  # fl <- fl[grep("broadPeak", fl)]
  #This is for safety if you want to grab the right file type from 'macs' output.
  
  # Let's subset this data for testing
  # In practice you'll want to run this on the full dataset.
  fl <- fl[1:20]
  
  # fl: this is just going to be a list of the peak file names
  # this used the R function "list.files" -- take a look:
  # ?list.files
  # So we have now read in all the file names in the paramater path.
  
  
  ## Here we are reading in files first again and putting them in the object "create_consensus_peaks"
  ## We are using grep to just grab broadPeak files. This is because the macs folder has many different
  ## versions of peak files. It is just useful to be sure it grabs the right file type.
  ## In our case the folder all_peak_files is only broadPeak files so a bit redundant....for safety.
  
  tf_name <- sapply(fl, get_dbp_name)
  
  ## Here we just named the file with str_extract and regex.
  # ?str_extract (need tidyverse library loaded)
  # The paramaters are:
  
  # string: the input vector of coerciable data (e.g. character string) -- peak_files
  # here we are using x that is being read in by the function which is an individual file name.
  
  
  #pattern: the pattern to look for across the input vector. this is using regular
  # expression (regex). You don't need to know this much regex, but if you are ever 
  # curious you can use the online regex calculator :)
  # 
  # https://regexr.com/
  # 
  # if you paste in the two regex commands below it will tell you what they are looking for.
  
  ## Now our goal is to associate the replicate files with a unique DBP name. So 
  ## 'unique_tf' will only provide one DBP name -- but will later be associated with
  ## each replicate file associated with that DBP name.
  
  unique_tf <- unique(tf_name)
  
  ## ?unique
  ## here we see the unique function provide information to index each DBP as a unique 
  ## entry.
  
  
  consensus_peaks <- list()
  
  # This for loop will iterate over all dna binding proteins.
  for (i in 1:length(unique_tf)) {
    # this is why we set up unique_tf above so the for loop will only run on one DBP
    # at a time, and merges the peaks of the replicate files associated with each DBP.
    # then the for loop will move onto the next unique_tf and merge those peak files.
    
    dbp <- unique_tf[i]
    
    cat("Now I'm running", dbp, "\n")
    # this is just a fun way of seeing the progress of the for loop -- also good
    # for debugging when a file fails -- you know the last successful run.
    
    tf_files <- fl[grep(dbp, fl)]
    # here we are creating dbp to use in grep to grab the dbp entry and find it in fl
    # this way we only intersect the replicate files that have the same dbp name.
    # this is why we indexed into unique_tf[i]. Then the next unique DBP name will
    # run in the next iteration of the loop.
    if (length(tf_files) > 1) {
      # turns out some files don't have replicates :( so we are saying here that if
      # the current (i) entry for 'tf_files' is equal or less than 1 to stop running.
      # we can't intersect peaks if there is only one peak file :)
      
      peak_list <- c()
      # making a new object peak list that will be populated by the loop below.
      # we leave it empty until the loop runs by simpling putting c()
      
      for (j in 1:length(tf_files)) {
        ## This for loop is going to go through each peak file and store it in peak_list
        
        peak_list <- c(peak_list, read_peaks(tf_files[j]))
      }
      
      # read_peaks is a function we already made in .util. It's pretty basic and 
      # commented out below
      
      # read_peaks <- function(broad_peak_file, filter_to_canonical_chr = TRUE) {
      
      # dat <- read.table(broad_peak_file, sep = "\t")
      # if(filter_to_canonical_chr == TRUE) {
      # dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
      # }
      # gr <- GRanges(seqnames = dat$V1,
      # ranges = IRanges(start=dat$V2,end=dat$V3))
      #return(gr)
      #}
      
      ## Read peaks is a good example of 'ranges' in action. notice the redundant cleaning up
      ## to cannonical chromosomes (which is also below).
      
      ## Setting up peak_list and printing 'c()' the information of read_peaks for a unique
      ## DBP that we set up above. This will result in read_peaks reading in the peaks from 
      ## the replicate files in tf_files will both be read in.
      
      
      canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
      # we are using paste0 to make a list of chr1 - chr22 and chrM etc
      # these are the only chromosomes we want so setting this up for below
      
      for (i in 1:length(peak_list)) {
        peak_list[[i]] <- peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
      }
      
      ## This for loop is going to look throuhg the peak_list and retreive only the
      ## seqnames 'which' (?seqnames) that are %in% (handy r function!) our cannonical chr list.
      final_peakset <- intersect_peaks(peak_list = peak_list)
      ## intersect peaks is a function we made in the util folder intersect_functions.R
      ## It basically uses the genomicRanges package findOverlaps that does the bulk 
      ## of the intersecting peaks between files in 'peak_files'
      ## the only parameter this function needs is the peak list object (they are named the same)
      ## Here is the intersect_peaks function below
      
      #    intersect_peaks <- function(peak_list) {
      #     combined_peaks <- peak_list[[1]]
      #     for(i in 2:length(peak_list)) {
      #     suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
      #   pl1 <- combined_peaks[unique(pl_ov@from)]
      #   pl2 <- peak_list[[i]][unique(pl_ov@to)]
      #   suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
      # }
      #  return(combined_peaks)
      #}
      
      ## of note the function reduce, that is a function that will merge two overlaping
      ## ranges. We take the union of peak in list 1 and 2 (pl1, pl2). This means if they
      ## overlap it will take the furtherst ends of the ranges. 
      
      ## now we return to the for loop with an 'if' statement that will only operate
      ## if the condition of the if statement are true. Here saying the final peak list
      ## needs to be greater than 0 -- otherwise there were no peaks.
      ## if greater than 0 peaks are found it will name each peak and put it into an
      ## object final_peakset and make a new column 'name' that consists of 
      ## the DBP (or TF) name with an underscore followed by the 1 through all the peaks
      ## that are in the final_peakset of overlapping peaks.
      if (length(final_peakset) > 0) {
        final_peakset$name <- paste0(dbp, "_", 1:length(final_peakset))
      } 
      
      consensus_peaks <- c(consensus_peaks, list(final_peakset))
      names(consensus_peaks)[length(consensus_peaks)] <- dbp
      
      ## Now we are just tidying and finalizing the consensus_peaks. First concatinating
      ## consensus_peaks with all the peaks in final_peakset. The list function is 
      ## listing all the peaks in final_peakset and printing them to consensus_peaks.
      ## lastly using names to name each peak by the DBP (or TF) using <- to input the
      ## DBP name.
    }
  }
  return(consensus_peaks)
}

```
